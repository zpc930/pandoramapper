// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.proto

#ifndef PROTOBUF_map_2eproto__INCLUDED
#define PROTOBUF_map_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mapdata {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_map_2eproto();
void protobuf_AssignDesc_map_2eproto();
void protobuf_ShutdownFile_map_2eproto();

class MapHeader;
class Area;
class Area_Alias;
class Exit;
class Exit_ExitFlags;
class Exit_DoorFlags;
class Room;
class Room_MobFlags;
class Room_LoadFlags;
class Room_Coordinate;

enum Exit_ExitType {
  Exit_ExitType_ET_NORMAL = 0,
  Exit_ExitType_ET_UNDEFINED = 3,
  Exit_ExitType_ET_DEATH = 4,
  Exit_ExitType_ET_NONE = 5
};
bool Exit_ExitType_IsValid(int value);
const Exit_ExitType Exit_ExitType_ExitType_MIN = Exit_ExitType_ET_NORMAL;
const Exit_ExitType Exit_ExitType_ExitType_MAX = Exit_ExitType_ET_NONE;
const int Exit_ExitType_ExitType_ARRAYSIZE = Exit_ExitType_ExitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Exit_ExitType_descriptor();
inline const ::std::string& Exit_ExitType_Name(Exit_ExitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Exit_ExitType_descriptor(), value);
}
inline bool Exit_ExitType_Parse(
    const ::std::string& name, Exit_ExitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Exit_ExitType>(
    Exit_ExitType_descriptor(), name, value);
}
enum Exit_ExitDirection {
  Exit_ExitDirection_ED_NORTH = 0,
  Exit_ExitDirection_ED_SOUTH = 1,
  Exit_ExitDirection_ED_EAST = 2,
  Exit_ExitDirection_ED_WEST = 3,
  Exit_ExitDirection_ED_UP = 4,
  Exit_ExitDirection_ED_DOWN = 5,
  Exit_ExitDirection_ED_UNKNOWN = 6
};
bool Exit_ExitDirection_IsValid(int value);
const Exit_ExitDirection Exit_ExitDirection_ExitDirection_MIN = Exit_ExitDirection_ED_NORTH;
const Exit_ExitDirection Exit_ExitDirection_ExitDirection_MAX = Exit_ExitDirection_ED_UNKNOWN;
const int Exit_ExitDirection_ExitDirection_ARRAYSIZE = Exit_ExitDirection_ExitDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* Exit_ExitDirection_descriptor();
inline const ::std::string& Exit_ExitDirection_Name(Exit_ExitDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    Exit_ExitDirection_descriptor(), value);
}
inline bool Exit_ExitDirection_Parse(
    const ::std::string& name, Exit_ExitDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Exit_ExitDirection>(
    Exit_ExitDirection_descriptor(), name, value);
}
enum Room_RoomTerrainType {
  Room_RoomTerrainType_RTT_UNDEFINED = 0,
  Room_RoomTerrainType_RTT_INDOORS = 1,
  Room_RoomTerrainType_RTT_CITY = 2,
  Room_RoomTerrainType_RTT_FIELD = 3,
  Room_RoomTerrainType_RTT_FOREST = 4,
  Room_RoomTerrainType_RTT_HILLS = 5,
  Room_RoomTerrainType_RTT_MOUNTAINS = 6,
  Room_RoomTerrainType_RTT_SHALLOW = 7,
  Room_RoomTerrainType_RTT_WATER = 8,
  Room_RoomTerrainType_RTT_RAPIDS = 9,
  Room_RoomTerrainType_RTT_UNDERWATER = 10,
  Room_RoomTerrainType_RTT_ROAD = 11,
  Room_RoomTerrainType_RTT_BRUSH = 12,
  Room_RoomTerrainType_RTT_TUNNEL = 13,
  Room_RoomTerrainType_RTT_CAVERN = 14,
  Room_RoomTerrainType_RTT_DEATHTRAP = 15,
  Room_RoomTerrainType_RTT_RANDOM = 16
};
bool Room_RoomTerrainType_IsValid(int value);
const Room_RoomTerrainType Room_RoomTerrainType_RoomTerrainType_MIN = Room_RoomTerrainType_RTT_UNDEFINED;
const Room_RoomTerrainType Room_RoomTerrainType_RoomTerrainType_MAX = Room_RoomTerrainType_RTT_RANDOM;
const int Room_RoomTerrainType_RoomTerrainType_ARRAYSIZE = Room_RoomTerrainType_RoomTerrainType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Room_RoomTerrainType_descriptor();
inline const ::std::string& Room_RoomTerrainType_Name(Room_RoomTerrainType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Room_RoomTerrainType_descriptor(), value);
}
inline bool Room_RoomTerrainType_Parse(
    const ::std::string& name, Room_RoomTerrainType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Room_RoomTerrainType>(
    Room_RoomTerrainType_descriptor(), name, value);
}
enum Room_RoomPortableType {
  Room_RoomPortableType_RPT_UNDEFINED = 0,
  Room_RoomPortableType_RPT_PORTABLE = 1,
  Room_RoomPortableType_RPT_NOTPORTABLE = 2
};
bool Room_RoomPortableType_IsValid(int value);
const Room_RoomPortableType Room_RoomPortableType_RoomPortableType_MIN = Room_RoomPortableType_RPT_UNDEFINED;
const Room_RoomPortableType Room_RoomPortableType_RoomPortableType_MAX = Room_RoomPortableType_RPT_NOTPORTABLE;
const int Room_RoomPortableType_RoomPortableType_ARRAYSIZE = Room_RoomPortableType_RoomPortableType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Room_RoomPortableType_descriptor();
inline const ::std::string& Room_RoomPortableType_Name(Room_RoomPortableType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Room_RoomPortableType_descriptor(), value);
}
inline bool Room_RoomPortableType_Parse(
    const ::std::string& name, Room_RoomPortableType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Room_RoomPortableType>(
    Room_RoomPortableType_descriptor(), name, value);
}
enum Room_RoomLightType {
  Room_RoomLightType_RLT_UNDEFINED = 0,
  Room_RoomLightType_RLT_DARK = 1,
  Room_RoomLightType_RLT_LIT = 2
};
bool Room_RoomLightType_IsValid(int value);
const Room_RoomLightType Room_RoomLightType_RoomLightType_MIN = Room_RoomLightType_RLT_UNDEFINED;
const Room_RoomLightType Room_RoomLightType_RoomLightType_MAX = Room_RoomLightType_RLT_LIT;
const int Room_RoomLightType_RoomLightType_ARRAYSIZE = Room_RoomLightType_RoomLightType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Room_RoomLightType_descriptor();
inline const ::std::string& Room_RoomLightType_Name(Room_RoomLightType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Room_RoomLightType_descriptor(), value);
}
inline bool Room_RoomLightType_Parse(
    const ::std::string& name, Room_RoomLightType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Room_RoomLightType>(
    Room_RoomLightType_descriptor(), name, value);
}
enum Room_RoomAlignType {
  Room_RoomAlignType_RAT_UNDEFINED = 0,
  Room_RoomAlignType_RAT_GOOD = 1,
  Room_RoomAlignType_RAT_NEUTRAL = 2,
  Room_RoomAlignType_RAT_EVIL = 3
};
bool Room_RoomAlignType_IsValid(int value);
const Room_RoomAlignType Room_RoomAlignType_RoomAlignType_MIN = Room_RoomAlignType_RAT_UNDEFINED;
const Room_RoomAlignType Room_RoomAlignType_RoomAlignType_MAX = Room_RoomAlignType_RAT_EVIL;
const int Room_RoomAlignType_RoomAlignType_ARRAYSIZE = Room_RoomAlignType_RoomAlignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Room_RoomAlignType_descriptor();
inline const ::std::string& Room_RoomAlignType_Name(Room_RoomAlignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Room_RoomAlignType_descriptor(), value);
}
inline bool Room_RoomAlignType_Parse(
    const ::std::string& name, Room_RoomAlignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Room_RoomAlignType>(
    Room_RoomAlignType_descriptor(), name, value);
}
enum Room_RoomRidableType {
  Room_RoomRidableType_RRT_UNDEFINED = 0,
  Room_RoomRidableType_RRT_RIDABLE = 1,
  Room_RoomRidableType_RRT_NOTRIDABLE = 2
};
bool Room_RoomRidableType_IsValid(int value);
const Room_RoomRidableType Room_RoomRidableType_RoomRidableType_MIN = Room_RoomRidableType_RRT_UNDEFINED;
const Room_RoomRidableType Room_RoomRidableType_RoomRidableType_MAX = Room_RoomRidableType_RRT_NOTRIDABLE;
const int Room_RoomRidableType_RoomRidableType_ARRAYSIZE = Room_RoomRidableType_RoomRidableType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Room_RoomRidableType_descriptor();
inline const ::std::string& Room_RoomRidableType_Name(Room_RoomRidableType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Room_RoomRidableType_descriptor(), value);
}
inline bool Room_RoomRidableType_Parse(
    const ::std::string& name, Room_RoomRidableType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Room_RoomRidableType>(
    Room_RoomRidableType_descriptor(), name, value);
}
// ===================================================================

class MapHeader : public ::google::protobuf::Message {
 public:
  MapHeader();
  virtual ~MapHeader();

  MapHeader(const MapHeader& from);

  inline MapHeader& operator=(const MapHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapHeader& default_instance();

  void Swap(MapHeader* other);

  // implements Message ----------------------------------------------

  MapHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapHeader& from);
  void MergeFrom(const MapHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rooms_amount = 1 [default = 0];
  inline bool has_rooms_amount() const;
  inline void clear_rooms_amount();
  static const int kRoomsAmountFieldNumber = 1;
  inline ::google::protobuf::int32 rooms_amount() const;
  inline void set_rooms_amount(::google::protobuf::int32 value);

  // optional int32 areas_amount = 2 [default = 0];
  inline bool has_areas_amount() const;
  inline void clear_areas_amount();
  static const int kAreasAmountFieldNumber = 2;
  inline ::google::protobuf::int32 areas_amount() const;
  inline void set_areas_amount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mapdata.MapHeader)
 private:
  inline void set_has_rooms_amount();
  inline void clear_has_rooms_amount();
  inline void set_has_areas_amount();
  inline void clear_has_areas_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 rooms_amount_;
  ::google::protobuf::int32 areas_amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static MapHeader* default_instance_;
};
// -------------------------------------------------------------------

class Area_Alias : public ::google::protobuf::Message {
 public:
  Area_Alias();
  virtual ~Area_Alias();

  Area_Alias(const Area_Alias& from);

  inline Area_Alias& operator=(const Area_Alias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Area_Alias& default_instance();

  void Swap(Area_Alias* other);

  // implements Message ----------------------------------------------

  Area_Alias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Area_Alias& from);
  void MergeFrom(const Area_Alias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string door = 2;
  inline bool has_door() const;
  inline void clear_door();
  static const int kDoorFieldNumber = 2;
  inline const ::std::string& door() const;
  inline void set_door(const ::std::string& value);
  inline void set_door(const char* value);
  inline void set_door(const char* value, size_t size);
  inline ::std::string* mutable_door();
  inline ::std::string* release_door();
  inline void set_allocated_door(::std::string* door);

  // @@protoc_insertion_point(class_scope:mapdata.Area.Alias)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_door();
  inline void clear_has_door();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* door_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Area_Alias* default_instance_;
};
// -------------------------------------------------------------------

class Area : public ::google::protobuf::Message {
 public:
  Area();
  virtual ~Area();

  Area(const Area& from);

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Area& default_instance();

  void Swap(Area* other);

  // implements Message ----------------------------------------------

  Area* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Area& from);
  void MergeFrom(const Area& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Area_Alias Alias;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .mapdata.Area.Alias alias = 2;
  inline int alias_size() const;
  inline void clear_alias();
  static const int kAliasFieldNumber = 2;
  inline const ::mapdata::Area_Alias& alias(int index) const;
  inline ::mapdata::Area_Alias* mutable_alias(int index);
  inline ::mapdata::Area_Alias* add_alias();
  inline const ::google::protobuf::RepeatedPtrField< ::mapdata::Area_Alias >&
      alias() const;
  inline ::google::protobuf::RepeatedPtrField< ::mapdata::Area_Alias >*
      mutable_alias();

  // optional float scale = 3 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 3;
  inline float scale() const;
  inline void set_scale(float value);

  // @@protoc_insertion_point(class_scope:mapdata.Area)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::mapdata::Area_Alias > alias_;
  float scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Area* default_instance_;
};
// -------------------------------------------------------------------

class Exit_ExitFlags : public ::google::protobuf::Message {
 public:
  Exit_ExitFlags();
  virtual ~Exit_ExitFlags();

  Exit_ExitFlags(const Exit_ExitFlags& from);

  inline Exit_ExitFlags& operator=(const Exit_ExitFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exit_ExitFlags& default_instance();

  void Swap(Exit_ExitFlags* other);

  // implements Message ----------------------------------------------

  Exit_ExitFlags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exit_ExitFlags& from);
  void MergeFrom(const Exit_ExitFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool road = 1 [default = false];
  inline bool has_road() const;
  inline void clear_road();
  static const int kRoadFieldNumber = 1;
  inline bool road() const;
  inline void set_road(bool value);

  // optional bool climb = 2 [default = false];
  inline bool has_climb() const;
  inline void clear_climb();
  static const int kClimbFieldNumber = 2;
  inline bool climb() const;
  inline void set_climb(bool value);

  // optional bool random = 3 [default = false];
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 3;
  inline bool random() const;
  inline void set_random(bool value);

  // optional bool special = 4 [default = false];
  inline bool has_special() const;
  inline void clear_special();
  static const int kSpecialFieldNumber = 4;
  inline bool special() const;
  inline void set_special(bool value);

  // optional bool no_match = 5 [default = false];
  inline bool has_no_match() const;
  inline void clear_no_match();
  static const int kNoMatchFieldNumber = 5;
  inline bool no_match() const;
  inline void set_no_match(bool value);

  // @@protoc_insertion_point(class_scope:mapdata.Exit.ExitFlags)
 private:
  inline void set_has_road();
  inline void clear_has_road();
  inline void set_has_climb();
  inline void clear_has_climb();
  inline void set_has_random();
  inline void clear_has_random();
  inline void set_has_special();
  inline void clear_has_special();
  inline void set_has_no_match();
  inline void clear_has_no_match();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool road_;
  bool climb_;
  bool random_;
  bool special_;
  bool no_match_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Exit_ExitFlags* default_instance_;
};
// -------------------------------------------------------------------

class Exit_DoorFlags : public ::google::protobuf::Message {
 public:
  Exit_DoorFlags();
  virtual ~Exit_DoorFlags();

  Exit_DoorFlags(const Exit_DoorFlags& from);

  inline Exit_DoorFlags& operator=(const Exit_DoorFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exit_DoorFlags& default_instance();

  void Swap(Exit_DoorFlags* other);

  // implements Message ----------------------------------------------

  Exit_DoorFlags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exit_DoorFlags& from);
  void MergeFrom(const Exit_DoorFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool needkey = 1 [default = false];
  inline bool has_needkey() const;
  inline void clear_needkey();
  static const int kNeedkeyFieldNumber = 1;
  inline bool needkey() const;
  inline void set_needkey(bool value);

  // optional bool noblock = 2 [default = false];
  inline bool has_noblock() const;
  inline void clear_noblock();
  static const int kNoblockFieldNumber = 2;
  inline bool noblock() const;
  inline void set_noblock(bool value);

  // optional bool nobreak = 3 [default = false];
  inline bool has_nobreak() const;
  inline void clear_nobreak();
  static const int kNobreakFieldNumber = 3;
  inline bool nobreak() const;
  inline void set_nobreak(bool value);

  // optional bool nopick = 4 [default = false];
  inline bool has_nopick() const;
  inline void clear_nopick();
  static const int kNopickFieldNumber = 4;
  inline bool nopick() const;
  inline void set_nopick(bool value);

  // optional bool delayed = 5 [default = false];
  inline bool has_delayed() const;
  inline void clear_delayed();
  static const int kDelayedFieldNumber = 5;
  inline bool delayed() const;
  inline void set_delayed(bool value);

  // @@protoc_insertion_point(class_scope:mapdata.Exit.DoorFlags)
 private:
  inline void set_has_needkey();
  inline void clear_has_needkey();
  inline void set_has_noblock();
  inline void clear_has_noblock();
  inline void set_has_nobreak();
  inline void clear_has_nobreak();
  inline void set_has_nopick();
  inline void clear_has_nopick();
  inline void set_has_delayed();
  inline void clear_has_delayed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool needkey_;
  bool noblock_;
  bool nobreak_;
  bool nopick_;
  bool delayed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Exit_DoorFlags* default_instance_;
};
// -------------------------------------------------------------------

class Exit : public ::google::protobuf::Message {
 public:
  Exit();
  virtual ~Exit();

  Exit(const Exit& from);

  inline Exit& operator=(const Exit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exit& default_instance();

  void Swap(Exit* other);

  // implements Message ----------------------------------------------

  Exit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exit& from);
  void MergeFrom(const Exit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Exit_ExitFlags ExitFlags;
  typedef Exit_DoorFlags DoorFlags;

  typedef Exit_ExitType ExitType;
  static const ExitType ET_NORMAL = Exit_ExitType_ET_NORMAL;
  static const ExitType ET_UNDEFINED = Exit_ExitType_ET_UNDEFINED;
  static const ExitType ET_DEATH = Exit_ExitType_ET_DEATH;
  static const ExitType ET_NONE = Exit_ExitType_ET_NONE;
  static inline bool ExitType_IsValid(int value) {
    return Exit_ExitType_IsValid(value);
  }
  static const ExitType ExitType_MIN =
    Exit_ExitType_ExitType_MIN;
  static const ExitType ExitType_MAX =
    Exit_ExitType_ExitType_MAX;
  static const int ExitType_ARRAYSIZE =
    Exit_ExitType_ExitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExitType_descriptor() {
    return Exit_ExitType_descriptor();
  }
  static inline const ::std::string& ExitType_Name(ExitType value) {
    return Exit_ExitType_Name(value);
  }
  static inline bool ExitType_Parse(const ::std::string& name,
      ExitType* value) {
    return Exit_ExitType_Parse(name, value);
  }

  typedef Exit_ExitDirection ExitDirection;
  static const ExitDirection ED_NORTH = Exit_ExitDirection_ED_NORTH;
  static const ExitDirection ED_SOUTH = Exit_ExitDirection_ED_SOUTH;
  static const ExitDirection ED_EAST = Exit_ExitDirection_ED_EAST;
  static const ExitDirection ED_WEST = Exit_ExitDirection_ED_WEST;
  static const ExitDirection ED_UP = Exit_ExitDirection_ED_UP;
  static const ExitDirection ED_DOWN = Exit_ExitDirection_ED_DOWN;
  static const ExitDirection ED_UNKNOWN = Exit_ExitDirection_ED_UNKNOWN;
  static inline bool ExitDirection_IsValid(int value) {
    return Exit_ExitDirection_IsValid(value);
  }
  static const ExitDirection ExitDirection_MIN =
    Exit_ExitDirection_ExitDirection_MIN;
  static const ExitDirection ExitDirection_MAX =
    Exit_ExitDirection_ExitDirection_MAX;
  static const int ExitDirection_ARRAYSIZE =
    Exit_ExitDirection_ExitDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExitDirection_descriptor() {
    return Exit_ExitDirection_descriptor();
  }
  static inline const ::std::string& ExitDirection_Name(ExitDirection value) {
    return Exit_ExitDirection_Name(value);
  }
  static inline bool ExitDirection_Parse(const ::std::string& name,
      ExitDirection* value) {
    return Exit_ExitDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mapdata.Exit.ExitDirection dir = 1 [default = ED_UNKNOWN];
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 1;
  inline ::mapdata::Exit_ExitDirection dir() const;
  inline void set_dir(::mapdata::Exit_ExitDirection value);

  // optional int32 leads_to_id = 2 [default = 0];
  inline bool has_leads_to_id() const;
  inline void clear_leads_to_id();
  static const int kLeadsToIdFieldNumber = 2;
  inline ::google::protobuf::int32 leads_to_id() const;
  inline void set_leads_to_id(::google::protobuf::int32 value);

  // optional .mapdata.Exit.ExitType type = 3 [default = ET_NONE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::mapdata::Exit_ExitType type() const;
  inline void set_type(::mapdata::Exit_ExitType value);

  // optional string door = 4;
  inline bool has_door() const;
  inline void clear_door();
  static const int kDoorFieldNumber = 4;
  inline const ::std::string& door() const;
  inline void set_door(const ::std::string& value);
  inline void set_door(const char* value);
  inline void set_door(const char* value, size_t size);
  inline ::std::string* mutable_door();
  inline ::std::string* release_door();
  inline void set_allocated_door(::std::string* door);

  // optional .mapdata.Exit.ExitFlags exit_flags = 5;
  inline bool has_exit_flags() const;
  inline void clear_exit_flags();
  static const int kExitFlagsFieldNumber = 5;
  inline const ::mapdata::Exit_ExitFlags& exit_flags() const;
  inline ::mapdata::Exit_ExitFlags* mutable_exit_flags();
  inline ::mapdata::Exit_ExitFlags* release_exit_flags();
  inline void set_allocated_exit_flags(::mapdata::Exit_ExitFlags* exit_flags);

  // optional .mapdata.Exit.DoorFlags door_flags = 6;
  inline bool has_door_flags() const;
  inline void clear_door_flags();
  static const int kDoorFlagsFieldNumber = 6;
  inline const ::mapdata::Exit_DoorFlags& door_flags() const;
  inline ::mapdata::Exit_DoorFlags* mutable_door_flags();
  inline ::mapdata::Exit_DoorFlags* release_door_flags();
  inline void set_allocated_door_flags(::mapdata::Exit_DoorFlags* door_flags);

  // @@protoc_insertion_point(class_scope:mapdata.Exit)
 private:
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_leads_to_id();
  inline void clear_has_leads_to_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_door();
  inline void clear_has_door();
  inline void set_has_exit_flags();
  inline void clear_has_exit_flags();
  inline void set_has_door_flags();
  inline void clear_has_door_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int dir_;
  ::google::protobuf::int32 leads_to_id_;
  ::std::string* door_;
  ::mapdata::Exit_ExitFlags* exit_flags_;
  ::mapdata::Exit_DoorFlags* door_flags_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Exit* default_instance_;
};
// -------------------------------------------------------------------

class Room_MobFlags : public ::google::protobuf::Message {
 public:
  Room_MobFlags();
  virtual ~Room_MobFlags();

  Room_MobFlags(const Room_MobFlags& from);

  inline Room_MobFlags& operator=(const Room_MobFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room_MobFlags& default_instance();

  void Swap(Room_MobFlags* other);

  // implements Message ----------------------------------------------

  Room_MobFlags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room_MobFlags& from);
  void MergeFrom(const Room_MobFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool rent = 1 [default = false];
  inline bool has_rent() const;
  inline void clear_rent();
  static const int kRentFieldNumber = 1;
  inline bool rent() const;
  inline void set_rent(bool value);

  // optional bool shop = 2 [default = false];
  inline bool has_shop() const;
  inline void clear_shop();
  static const int kShopFieldNumber = 2;
  inline bool shop() const;
  inline void set_shop(bool value);

  // optional bool weaponshop = 3 [default = false];
  inline bool has_weaponshop() const;
  inline void clear_weaponshop();
  static const int kWeaponshopFieldNumber = 3;
  inline bool weaponshop() const;
  inline void set_weaponshop(bool value);

  // optional bool armourshop = 4 [default = false];
  inline bool has_armourshop() const;
  inline void clear_armourshop();
  static const int kArmourshopFieldNumber = 4;
  inline bool armourshop() const;
  inline void set_armourshop(bool value);

  // optional bool foodshop = 5 [default = false];
  inline bool has_foodshop() const;
  inline void clear_foodshop();
  static const int kFoodshopFieldNumber = 5;
  inline bool foodshop() const;
  inline void set_foodshop(bool value);

  // optional bool petshop = 6 [default = false];
  inline bool has_petshop() const;
  inline void clear_petshop();
  static const int kPetshopFieldNumber = 6;
  inline bool petshop() const;
  inline void set_petshop(bool value);

  // optional bool guild = 7 [default = false];
  inline bool has_guild() const;
  inline void clear_guild();
  static const int kGuildFieldNumber = 7;
  inline bool guild() const;
  inline void set_guild(bool value);

  // optional bool scoutguild = 8 [default = false];
  inline bool has_scoutguild() const;
  inline void clear_scoutguild();
  static const int kScoutguildFieldNumber = 8;
  inline bool scoutguild() const;
  inline void set_scoutguild(bool value);

  // optional bool mageguild = 9 [default = false];
  inline bool has_mageguild() const;
  inline void clear_mageguild();
  static const int kMageguildFieldNumber = 9;
  inline bool mageguild() const;
  inline void set_mageguild(bool value);

  // optional bool clericguild = 10 [default = false];
  inline bool has_clericguild() const;
  inline void clear_clericguild();
  static const int kClericguildFieldNumber = 10;
  inline bool clericguild() const;
  inline void set_clericguild(bool value);

  // optional bool warriorguild = 11 [default = false];
  inline bool has_warriorguild() const;
  inline void clear_warriorguild();
  static const int kWarriorguildFieldNumber = 11;
  inline bool warriorguild() const;
  inline void set_warriorguild(bool value);

  // optional bool rangerguild = 12 [default = false];
  inline bool has_rangerguild() const;
  inline void clear_rangerguild();
  static const int kRangerguildFieldNumber = 12;
  inline bool rangerguild() const;
  inline void set_rangerguild(bool value);

  // optional bool smob = 13 [default = false];
  inline bool has_smob() const;
  inline void clear_smob();
  static const int kSmobFieldNumber = 13;
  inline bool smob() const;
  inline void set_smob(bool value);

  // optional bool quest = 14 [default = false];
  inline bool has_quest() const;
  inline void clear_quest();
  static const int kQuestFieldNumber = 14;
  inline bool quest() const;
  inline void set_quest(bool value);

  // optional bool any = 15 [default = false];
  inline bool has_any() const;
  inline void clear_any();
  static const int kAnyFieldNumber = 15;
  inline bool any() const;
  inline void set_any(bool value);

  // @@protoc_insertion_point(class_scope:mapdata.Room.MobFlags)
 private:
  inline void set_has_rent();
  inline void clear_has_rent();
  inline void set_has_shop();
  inline void clear_has_shop();
  inline void set_has_weaponshop();
  inline void clear_has_weaponshop();
  inline void set_has_armourshop();
  inline void clear_has_armourshop();
  inline void set_has_foodshop();
  inline void clear_has_foodshop();
  inline void set_has_petshop();
  inline void clear_has_petshop();
  inline void set_has_guild();
  inline void clear_has_guild();
  inline void set_has_scoutguild();
  inline void clear_has_scoutguild();
  inline void set_has_mageguild();
  inline void clear_has_mageguild();
  inline void set_has_clericguild();
  inline void clear_has_clericguild();
  inline void set_has_warriorguild();
  inline void clear_has_warriorguild();
  inline void set_has_rangerguild();
  inline void clear_has_rangerguild();
  inline void set_has_smob();
  inline void clear_has_smob();
  inline void set_has_quest();
  inline void clear_has_quest();
  inline void set_has_any();
  inline void clear_has_any();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool rent_;
  bool shop_;
  bool weaponshop_;
  bool armourshop_;
  bool foodshop_;
  bool petshop_;
  bool guild_;
  bool scoutguild_;
  bool mageguild_;
  bool clericguild_;
  bool warriorguild_;
  bool rangerguild_;
  bool smob_;
  bool quest_;
  bool any_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Room_MobFlags* default_instance_;
};
// -------------------------------------------------------------------

class Room_LoadFlags : public ::google::protobuf::Message {
 public:
  Room_LoadFlags();
  virtual ~Room_LoadFlags();

  Room_LoadFlags(const Room_LoadFlags& from);

  inline Room_LoadFlags& operator=(const Room_LoadFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room_LoadFlags& default_instance();

  void Swap(Room_LoadFlags* other);

  // implements Message ----------------------------------------------

  Room_LoadFlags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room_LoadFlags& from);
  void MergeFrom(const Room_LoadFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool treasure = 1 [default = false];
  inline bool has_treasure() const;
  inline void clear_treasure();
  static const int kTreasureFieldNumber = 1;
  inline bool treasure() const;
  inline void set_treasure(bool value);

  // optional bool armour = 2 [default = false];
  inline bool has_armour() const;
  inline void clear_armour();
  static const int kArmourFieldNumber = 2;
  inline bool armour() const;
  inline void set_armour(bool value);

  // optional bool weapon = 3 [default = false];
  inline bool has_weapon() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 3;
  inline bool weapon() const;
  inline void set_weapon(bool value);

  // optional bool water = 4 [default = false];
  inline bool has_water() const;
  inline void clear_water();
  static const int kWaterFieldNumber = 4;
  inline bool water() const;
  inline void set_water(bool value);

  // optional bool food = 5 [default = false];
  inline bool has_food() const;
  inline void clear_food();
  static const int kFoodFieldNumber = 5;
  inline bool food() const;
  inline void set_food(bool value);

  // optional bool herb = 6 [default = false];
  inline bool has_herb() const;
  inline void clear_herb();
  static const int kHerbFieldNumber = 6;
  inline bool herb() const;
  inline void set_herb(bool value);

  // optional bool key = 7 [default = false];
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 7;
  inline bool key() const;
  inline void set_key(bool value);

  // optional bool mule = 8 [default = false];
  inline bool has_mule() const;
  inline void clear_mule();
  static const int kMuleFieldNumber = 8;
  inline bool mule() const;
  inline void set_mule(bool value);

  // optional bool horse = 9 [default = false];
  inline bool has_horse() const;
  inline void clear_horse();
  static const int kHorseFieldNumber = 9;
  inline bool horse() const;
  inline void set_horse(bool value);

  // optional bool packhorse = 10 [default = false];
  inline bool has_packhorse() const;
  inline void clear_packhorse();
  static const int kPackhorseFieldNumber = 10;
  inline bool packhorse() const;
  inline void set_packhorse(bool value);

  // optional bool trainedhorse = 11 [default = false];
  inline bool has_trainedhorse() const;
  inline void clear_trainedhorse();
  static const int kTrainedhorseFieldNumber = 11;
  inline bool trainedhorse() const;
  inline void set_trainedhorse(bool value);

  // optional bool rohirrim = 12 [default = false];
  inline bool has_rohirrim() const;
  inline void clear_rohirrim();
  static const int kRohirrimFieldNumber = 12;
  inline bool rohirrim() const;
  inline void set_rohirrim(bool value);

  // optional bool warg = 13 [default = false];
  inline bool has_warg() const;
  inline void clear_warg();
  static const int kWargFieldNumber = 13;
  inline bool warg() const;
  inline void set_warg(bool value);

  // optional bool boat = 14 [default = false];
  inline bool has_boat() const;
  inline void clear_boat();
  static const int kBoatFieldNumber = 14;
  inline bool boat() const;
  inline void set_boat(bool value);

  // optional bool attention = 15 [default = false];
  inline bool has_attention() const;
  inline void clear_attention();
  static const int kAttentionFieldNumber = 15;
  inline bool attention() const;
  inline void set_attention(bool value);

  // optional bool tower = 16 [default = false];
  inline bool has_tower() const;
  inline void clear_tower();
  static const int kTowerFieldNumber = 16;
  inline bool tower() const;
  inline void set_tower(bool value);

  // @@protoc_insertion_point(class_scope:mapdata.Room.LoadFlags)
 private:
  inline void set_has_treasure();
  inline void clear_has_treasure();
  inline void set_has_armour();
  inline void clear_has_armour();
  inline void set_has_weapon();
  inline void clear_has_weapon();
  inline void set_has_water();
  inline void clear_has_water();
  inline void set_has_food();
  inline void clear_has_food();
  inline void set_has_herb();
  inline void clear_has_herb();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_mule();
  inline void clear_has_mule();
  inline void set_has_horse();
  inline void clear_has_horse();
  inline void set_has_packhorse();
  inline void clear_has_packhorse();
  inline void set_has_trainedhorse();
  inline void clear_has_trainedhorse();
  inline void set_has_rohirrim();
  inline void clear_has_rohirrim();
  inline void set_has_warg();
  inline void clear_has_warg();
  inline void set_has_boat();
  inline void clear_has_boat();
  inline void set_has_attention();
  inline void clear_has_attention();
  inline void set_has_tower();
  inline void clear_has_tower();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool treasure_;
  bool armour_;
  bool weapon_;
  bool water_;
  bool food_;
  bool herb_;
  bool key_;
  bool mule_;
  bool horse_;
  bool packhorse_;
  bool trainedhorse_;
  bool rohirrim_;
  bool warg_;
  bool boat_;
  bool attention_;
  bool tower_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Room_LoadFlags* default_instance_;
};
// -------------------------------------------------------------------

class Room_Coordinate : public ::google::protobuf::Message {
 public:
  Room_Coordinate();
  virtual ~Room_Coordinate();

  Room_Coordinate(const Room_Coordinate& from);

  inline Room_Coordinate& operator=(const Room_Coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room_Coordinate& default_instance();

  void Swap(Room_Coordinate* other);

  // implements Message ----------------------------------------------

  Room_Coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room_Coordinate& from);
  void MergeFrom(const Room_Coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // optional float scale = 4 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  inline float scale() const;
  inline void set_scale(float value);

  // @@protoc_insertion_point(class_scope:mapdata.Room.Coordinate)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;
  float scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Room_Coordinate* default_instance_;
};
// -------------------------------------------------------------------

class Room : public ::google::protobuf::Message {
 public:
  Room();
  virtual ~Room();

  Room(const Room& from);

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room& default_instance();

  void Swap(Room* other);

  // implements Message ----------------------------------------------

  Room* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Room_MobFlags MobFlags;
  typedef Room_LoadFlags LoadFlags;
  typedef Room_Coordinate Coordinate;

  typedef Room_RoomTerrainType RoomTerrainType;
  static const RoomTerrainType RTT_UNDEFINED = Room_RoomTerrainType_RTT_UNDEFINED;
  static const RoomTerrainType RTT_INDOORS = Room_RoomTerrainType_RTT_INDOORS;
  static const RoomTerrainType RTT_CITY = Room_RoomTerrainType_RTT_CITY;
  static const RoomTerrainType RTT_FIELD = Room_RoomTerrainType_RTT_FIELD;
  static const RoomTerrainType RTT_FOREST = Room_RoomTerrainType_RTT_FOREST;
  static const RoomTerrainType RTT_HILLS = Room_RoomTerrainType_RTT_HILLS;
  static const RoomTerrainType RTT_MOUNTAINS = Room_RoomTerrainType_RTT_MOUNTAINS;
  static const RoomTerrainType RTT_SHALLOW = Room_RoomTerrainType_RTT_SHALLOW;
  static const RoomTerrainType RTT_WATER = Room_RoomTerrainType_RTT_WATER;
  static const RoomTerrainType RTT_RAPIDS = Room_RoomTerrainType_RTT_RAPIDS;
  static const RoomTerrainType RTT_UNDERWATER = Room_RoomTerrainType_RTT_UNDERWATER;
  static const RoomTerrainType RTT_ROAD = Room_RoomTerrainType_RTT_ROAD;
  static const RoomTerrainType RTT_BRUSH = Room_RoomTerrainType_RTT_BRUSH;
  static const RoomTerrainType RTT_TUNNEL = Room_RoomTerrainType_RTT_TUNNEL;
  static const RoomTerrainType RTT_CAVERN = Room_RoomTerrainType_RTT_CAVERN;
  static const RoomTerrainType RTT_DEATHTRAP = Room_RoomTerrainType_RTT_DEATHTRAP;
  static const RoomTerrainType RTT_RANDOM = Room_RoomTerrainType_RTT_RANDOM;
  static inline bool RoomTerrainType_IsValid(int value) {
    return Room_RoomTerrainType_IsValid(value);
  }
  static const RoomTerrainType RoomTerrainType_MIN =
    Room_RoomTerrainType_RoomTerrainType_MIN;
  static const RoomTerrainType RoomTerrainType_MAX =
    Room_RoomTerrainType_RoomTerrainType_MAX;
  static const int RoomTerrainType_ARRAYSIZE =
    Room_RoomTerrainType_RoomTerrainType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomTerrainType_descriptor() {
    return Room_RoomTerrainType_descriptor();
  }
  static inline const ::std::string& RoomTerrainType_Name(RoomTerrainType value) {
    return Room_RoomTerrainType_Name(value);
  }
  static inline bool RoomTerrainType_Parse(const ::std::string& name,
      RoomTerrainType* value) {
    return Room_RoomTerrainType_Parse(name, value);
  }

  typedef Room_RoomPortableType RoomPortableType;
  static const RoomPortableType RPT_UNDEFINED = Room_RoomPortableType_RPT_UNDEFINED;
  static const RoomPortableType RPT_PORTABLE = Room_RoomPortableType_RPT_PORTABLE;
  static const RoomPortableType RPT_NOTPORTABLE = Room_RoomPortableType_RPT_NOTPORTABLE;
  static inline bool RoomPortableType_IsValid(int value) {
    return Room_RoomPortableType_IsValid(value);
  }
  static const RoomPortableType RoomPortableType_MIN =
    Room_RoomPortableType_RoomPortableType_MIN;
  static const RoomPortableType RoomPortableType_MAX =
    Room_RoomPortableType_RoomPortableType_MAX;
  static const int RoomPortableType_ARRAYSIZE =
    Room_RoomPortableType_RoomPortableType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomPortableType_descriptor() {
    return Room_RoomPortableType_descriptor();
  }
  static inline const ::std::string& RoomPortableType_Name(RoomPortableType value) {
    return Room_RoomPortableType_Name(value);
  }
  static inline bool RoomPortableType_Parse(const ::std::string& name,
      RoomPortableType* value) {
    return Room_RoomPortableType_Parse(name, value);
  }

  typedef Room_RoomLightType RoomLightType;
  static const RoomLightType RLT_UNDEFINED = Room_RoomLightType_RLT_UNDEFINED;
  static const RoomLightType RLT_DARK = Room_RoomLightType_RLT_DARK;
  static const RoomLightType RLT_LIT = Room_RoomLightType_RLT_LIT;
  static inline bool RoomLightType_IsValid(int value) {
    return Room_RoomLightType_IsValid(value);
  }
  static const RoomLightType RoomLightType_MIN =
    Room_RoomLightType_RoomLightType_MIN;
  static const RoomLightType RoomLightType_MAX =
    Room_RoomLightType_RoomLightType_MAX;
  static const int RoomLightType_ARRAYSIZE =
    Room_RoomLightType_RoomLightType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomLightType_descriptor() {
    return Room_RoomLightType_descriptor();
  }
  static inline const ::std::string& RoomLightType_Name(RoomLightType value) {
    return Room_RoomLightType_Name(value);
  }
  static inline bool RoomLightType_Parse(const ::std::string& name,
      RoomLightType* value) {
    return Room_RoomLightType_Parse(name, value);
  }

  typedef Room_RoomAlignType RoomAlignType;
  static const RoomAlignType RAT_UNDEFINED = Room_RoomAlignType_RAT_UNDEFINED;
  static const RoomAlignType RAT_GOOD = Room_RoomAlignType_RAT_GOOD;
  static const RoomAlignType RAT_NEUTRAL = Room_RoomAlignType_RAT_NEUTRAL;
  static const RoomAlignType RAT_EVIL = Room_RoomAlignType_RAT_EVIL;
  static inline bool RoomAlignType_IsValid(int value) {
    return Room_RoomAlignType_IsValid(value);
  }
  static const RoomAlignType RoomAlignType_MIN =
    Room_RoomAlignType_RoomAlignType_MIN;
  static const RoomAlignType RoomAlignType_MAX =
    Room_RoomAlignType_RoomAlignType_MAX;
  static const int RoomAlignType_ARRAYSIZE =
    Room_RoomAlignType_RoomAlignType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomAlignType_descriptor() {
    return Room_RoomAlignType_descriptor();
  }
  static inline const ::std::string& RoomAlignType_Name(RoomAlignType value) {
    return Room_RoomAlignType_Name(value);
  }
  static inline bool RoomAlignType_Parse(const ::std::string& name,
      RoomAlignType* value) {
    return Room_RoomAlignType_Parse(name, value);
  }

  typedef Room_RoomRidableType RoomRidableType;
  static const RoomRidableType RRT_UNDEFINED = Room_RoomRidableType_RRT_UNDEFINED;
  static const RoomRidableType RRT_RIDABLE = Room_RoomRidableType_RRT_RIDABLE;
  static const RoomRidableType RRT_NOTRIDABLE = Room_RoomRidableType_RRT_NOTRIDABLE;
  static inline bool RoomRidableType_IsValid(int value) {
    return Room_RoomRidableType_IsValid(value);
  }
  static const RoomRidableType RoomRidableType_MIN =
    Room_RoomRidableType_RoomRidableType_MIN;
  static const RoomRidableType RoomRidableType_MAX =
    Room_RoomRidableType_RoomRidableType_MAX;
  static const int RoomRidableType_ARRAYSIZE =
    Room_RoomRidableType_RoomRidableType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoomRidableType_descriptor() {
    return Room_RoomRidableType_descriptor();
  }
  static inline const ::std::string& RoomRidableType_Name(RoomRidableType value) {
    return Room_RoomRidableType_Name(value);
  }
  static inline bool RoomRidableType_Parse(const ::std::string& name,
      RoomRidableType* value) {
    return Room_RoomRidableType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string desc = 3 [default = ""];
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required .mapdata.Room.Coordinate pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline const ::mapdata::Room_Coordinate& pos() const;
  inline ::mapdata::Room_Coordinate* mutable_pos();
  inline ::mapdata::Room_Coordinate* release_pos();
  inline void set_allocated_pos(::mapdata::Room_Coordinate* pos);

  // optional string area_name = 6 [default = "default"];
  inline bool has_area_name() const;
  inline void clear_area_name();
  static const int kAreaNameFieldNumber = 6;
  inline const ::std::string& area_name() const;
  inline void set_area_name(const ::std::string& value);
  inline void set_area_name(const char* value);
  inline void set_area_name(const char* value, size_t size);
  inline ::std::string* mutable_area_name();
  inline ::std::string* release_area_name();
  inline void set_allocated_area_name(::std::string* area_name);

  // optional string dynamicDesc = 7;
  inline bool has_dynamicdesc() const;
  inline void clear_dynamicdesc();
  static const int kDynamicDescFieldNumber = 7;
  inline const ::std::string& dynamicdesc() const;
  inline void set_dynamicdesc(const ::std::string& value);
  inline void set_dynamicdesc(const char* value);
  inline void set_dynamicdesc(const char* value, size_t size);
  inline ::std::string* mutable_dynamicdesc();
  inline ::std::string* release_dynamicdesc();
  inline void set_allocated_dynamicdesc(::std::string* dynamicdesc);

  // optional .mapdata.Room.RoomTerrainType terrain = 8 [default = RTT_UNDEFINED];
  inline bool has_terrain() const;
  inline void clear_terrain();
  static const int kTerrainFieldNumber = 8;
  inline ::mapdata::Room_RoomTerrainType terrain() const;
  inline void set_terrain(::mapdata::Room_RoomTerrainType value);

  // repeated .mapdata.Exit exits = 9;
  inline int exits_size() const;
  inline void clear_exits();
  static const int kExitsFieldNumber = 9;
  inline const ::mapdata::Exit& exits(int index) const;
  inline ::mapdata::Exit* mutable_exits(int index);
  inline ::mapdata::Exit* add_exits();
  inline const ::google::protobuf::RepeatedPtrField< ::mapdata::Exit >&
      exits() const;
  inline ::google::protobuf::RepeatedPtrField< ::mapdata::Exit >*
      mutable_exits();

  // optional string note = 15;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 15;
  inline const ::std::string& note() const;
  inline void set_note(const ::std::string& value);
  inline void set_note(const char* value);
  inline void set_note(const char* value, size_t size);
  inline ::std::string* mutable_note();
  inline ::std::string* release_note();
  inline void set_allocated_note(::std::string* note);

  // optional string note_color = 16;
  inline bool has_note_color() const;
  inline void clear_note_color();
  static const int kNoteColorFieldNumber = 16;
  inline const ::std::string& note_color() const;
  inline void set_note_color(const ::std::string& value);
  inline void set_note_color(const char* value);
  inline void set_note_color(const char* value, size_t size);
  inline ::std::string* mutable_note_color();
  inline ::std::string* release_note_color();
  inline void set_allocated_note_color(::std::string* note_color);

  // optional string info = 17;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 17;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // optional .mapdata.Room.RoomPortableType flag_portable = 18 [default = RPT_UNDEFINED];
  inline bool has_flag_portable() const;
  inline void clear_flag_portable();
  static const int kFlagPortableFieldNumber = 18;
  inline ::mapdata::Room_RoomPortableType flag_portable() const;
  inline void set_flag_portable(::mapdata::Room_RoomPortableType value);

  // optional .mapdata.Room.RoomLightType flag_light = 19 [default = RLT_UNDEFINED];
  inline bool has_flag_light() const;
  inline void clear_flag_light();
  static const int kFlagLightFieldNumber = 19;
  inline ::mapdata::Room_RoomLightType flag_light() const;
  inline void set_flag_light(::mapdata::Room_RoomLightType value);

  // optional .mapdata.Room.RoomRidableType flag_rideable = 20 [default = RRT_UNDEFINED];
  inline bool has_flag_rideable() const;
  inline void clear_flag_rideable();
  static const int kFlagRideableFieldNumber = 20;
  inline ::mapdata::Room_RoomRidableType flag_rideable() const;
  inline void set_flag_rideable(::mapdata::Room_RoomRidableType value);

  // optional .mapdata.Room.RoomAlignType flag_align = 21 [default = RAT_UNDEFINED];
  inline bool has_flag_align() const;
  inline void clear_flag_align();
  static const int kFlagAlignFieldNumber = 21;
  inline ::mapdata::Room_RoomAlignType flag_align() const;
  inline void set_flag_align(::mapdata::Room_RoomAlignType value);

  // optional .mapdata.Room.MobFlags mob_flags = 22;
  inline bool has_mob_flags() const;
  inline void clear_mob_flags();
  static const int kMobFlagsFieldNumber = 22;
  inline const ::mapdata::Room_MobFlags& mob_flags() const;
  inline ::mapdata::Room_MobFlags* mutable_mob_flags();
  inline ::mapdata::Room_MobFlags* release_mob_flags();
  inline void set_allocated_mob_flags(::mapdata::Room_MobFlags* mob_flags);

  // optional .mapdata.Room.LoadFlags load_flags = 23;
  inline bool has_load_flags() const;
  inline void clear_load_flags();
  static const int kLoadFlagsFieldNumber = 23;
  inline const ::mapdata::Room_LoadFlags& load_flags() const;
  inline ::mapdata::Room_LoadFlags* mutable_load_flags();
  inline ::mapdata::Room_LoadFlags* release_load_flags();
  inline void set_allocated_load_flags(::mapdata::Room_LoadFlags* load_flags);

  // @@protoc_insertion_point(class_scope:mapdata.Room)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_area_name();
  inline void clear_has_area_name();
  inline void set_has_dynamicdesc();
  inline void clear_has_dynamicdesc();
  inline void set_has_terrain();
  inline void clear_has_terrain();
  inline void set_has_note();
  inline void clear_has_note();
  inline void set_has_note_color();
  inline void clear_has_note_color();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_flag_portable();
  inline void clear_has_flag_portable();
  inline void set_has_flag_light();
  inline void clear_has_flag_light();
  inline void set_has_flag_rideable();
  inline void clear_has_flag_rideable();
  inline void set_has_flag_align();
  inline void clear_has_flag_align();
  inline void set_has_mob_flags();
  inline void clear_has_mob_flags();
  inline void set_has_load_flags();
  inline void clear_has_load_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* desc_;
  ::mapdata::Room_Coordinate* pos_;
  ::google::protobuf::int32 id_;
  int terrain_;
  ::std::string* area_name_;
  static ::std::string* _default_area_name_;
  ::std::string* dynamicdesc_;
  ::google::protobuf::RepeatedPtrField< ::mapdata::Exit > exits_;
  ::std::string* note_;
  ::std::string* note_color_;
  ::std::string* info_;
  int flag_portable_;
  int flag_light_;
  int flag_rideable_;
  int flag_align_;
  ::mapdata::Room_MobFlags* mob_flags_;
  ::mapdata::Room_LoadFlags* load_flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_map_2eproto();
  friend void protobuf_AssignDesc_map_2eproto();
  friend void protobuf_ShutdownFile_map_2eproto();

  void InitAsDefaultInstance();
  static Room* default_instance_;
};
// ===================================================================


// ===================================================================

// MapHeader

// optional int32 rooms_amount = 1 [default = 0];
inline bool MapHeader::has_rooms_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapHeader::set_has_rooms_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapHeader::clear_has_rooms_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapHeader::clear_rooms_amount() {
  rooms_amount_ = 0;
  clear_has_rooms_amount();
}
inline ::google::protobuf::int32 MapHeader::rooms_amount() const {
  return rooms_amount_;
}
inline void MapHeader::set_rooms_amount(::google::protobuf::int32 value) {
  set_has_rooms_amount();
  rooms_amount_ = value;
}

// optional int32 areas_amount = 2 [default = 0];
inline bool MapHeader::has_areas_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapHeader::set_has_areas_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapHeader::clear_has_areas_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapHeader::clear_areas_amount() {
  areas_amount_ = 0;
  clear_has_areas_amount();
}
inline ::google::protobuf::int32 MapHeader::areas_amount() const {
  return areas_amount_;
}
inline void MapHeader::set_areas_amount(::google::protobuf::int32 value) {
  set_has_areas_amount();
  areas_amount_ = value;
}

// -------------------------------------------------------------------

// Area_Alias

// required string name = 1;
inline bool Area_Alias::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Area_Alias::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Area_Alias::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Area_Alias::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Area_Alias::name() const {
  return *name_;
}
inline void Area_Alias::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Area_Alias::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Area_Alias::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Area_Alias::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Area_Alias::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Area_Alias::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string door = 2;
inline bool Area_Alias::has_door() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Area_Alias::set_has_door() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Area_Alias::clear_has_door() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Area_Alias::clear_door() {
  if (door_ != &::google::protobuf::internal::kEmptyString) {
    door_->clear();
  }
  clear_has_door();
}
inline const ::std::string& Area_Alias::door() const {
  return *door_;
}
inline void Area_Alias::set_door(const ::std::string& value) {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  door_->assign(value);
}
inline void Area_Alias::set_door(const char* value) {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  door_->assign(value);
}
inline void Area_Alias::set_door(const char* value, size_t size) {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  door_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Area_Alias::mutable_door() {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  return door_;
}
inline ::std::string* Area_Alias::release_door() {
  clear_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = door_;
    door_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Area_Alias::set_allocated_door(::std::string* door) {
  if (door_ != &::google::protobuf::internal::kEmptyString) {
    delete door_;
  }
  if (door) {
    set_has_door();
    door_ = door;
  } else {
    clear_has_door();
    door_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Area

// required string name = 1;
inline bool Area::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Area::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Area::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Area::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Area::name() const {
  return *name_;
}
inline void Area::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Area::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Area::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Area::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Area::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Area::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .mapdata.Area.Alias alias = 2;
inline int Area::alias_size() const {
  return alias_.size();
}
inline void Area::clear_alias() {
  alias_.Clear();
}
inline const ::mapdata::Area_Alias& Area::alias(int index) const {
  return alias_.Get(index);
}
inline ::mapdata::Area_Alias* Area::mutable_alias(int index) {
  return alias_.Mutable(index);
}
inline ::mapdata::Area_Alias* Area::add_alias() {
  return alias_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mapdata::Area_Alias >&
Area::alias() const {
  return alias_;
}
inline ::google::protobuf::RepeatedPtrField< ::mapdata::Area_Alias >*
Area::mutable_alias() {
  return &alias_;
}

// optional float scale = 3 [default = 1];
inline bool Area::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Area::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Area::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Area::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float Area::scale() const {
  return scale_;
}
inline void Area::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// -------------------------------------------------------------------

// Exit_ExitFlags

// optional bool road = 1 [default = false];
inline bool Exit_ExitFlags::has_road() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exit_ExitFlags::set_has_road() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exit_ExitFlags::clear_has_road() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exit_ExitFlags::clear_road() {
  road_ = false;
  clear_has_road();
}
inline bool Exit_ExitFlags::road() const {
  return road_;
}
inline void Exit_ExitFlags::set_road(bool value) {
  set_has_road();
  road_ = value;
}

// optional bool climb = 2 [default = false];
inline bool Exit_ExitFlags::has_climb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exit_ExitFlags::set_has_climb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exit_ExitFlags::clear_has_climb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exit_ExitFlags::clear_climb() {
  climb_ = false;
  clear_has_climb();
}
inline bool Exit_ExitFlags::climb() const {
  return climb_;
}
inline void Exit_ExitFlags::set_climb(bool value) {
  set_has_climb();
  climb_ = value;
}

// optional bool random = 3 [default = false];
inline bool Exit_ExitFlags::has_random() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Exit_ExitFlags::set_has_random() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Exit_ExitFlags::clear_has_random() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Exit_ExitFlags::clear_random() {
  random_ = false;
  clear_has_random();
}
inline bool Exit_ExitFlags::random() const {
  return random_;
}
inline void Exit_ExitFlags::set_random(bool value) {
  set_has_random();
  random_ = value;
}

// optional bool special = 4 [default = false];
inline bool Exit_ExitFlags::has_special() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Exit_ExitFlags::set_has_special() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Exit_ExitFlags::clear_has_special() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Exit_ExitFlags::clear_special() {
  special_ = false;
  clear_has_special();
}
inline bool Exit_ExitFlags::special() const {
  return special_;
}
inline void Exit_ExitFlags::set_special(bool value) {
  set_has_special();
  special_ = value;
}

// optional bool no_match = 5 [default = false];
inline bool Exit_ExitFlags::has_no_match() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Exit_ExitFlags::set_has_no_match() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Exit_ExitFlags::clear_has_no_match() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Exit_ExitFlags::clear_no_match() {
  no_match_ = false;
  clear_has_no_match();
}
inline bool Exit_ExitFlags::no_match() const {
  return no_match_;
}
inline void Exit_ExitFlags::set_no_match(bool value) {
  set_has_no_match();
  no_match_ = value;
}

// -------------------------------------------------------------------

// Exit_DoorFlags

// optional bool needkey = 1 [default = false];
inline bool Exit_DoorFlags::has_needkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exit_DoorFlags::set_has_needkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exit_DoorFlags::clear_has_needkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exit_DoorFlags::clear_needkey() {
  needkey_ = false;
  clear_has_needkey();
}
inline bool Exit_DoorFlags::needkey() const {
  return needkey_;
}
inline void Exit_DoorFlags::set_needkey(bool value) {
  set_has_needkey();
  needkey_ = value;
}

// optional bool noblock = 2 [default = false];
inline bool Exit_DoorFlags::has_noblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exit_DoorFlags::set_has_noblock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exit_DoorFlags::clear_has_noblock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exit_DoorFlags::clear_noblock() {
  noblock_ = false;
  clear_has_noblock();
}
inline bool Exit_DoorFlags::noblock() const {
  return noblock_;
}
inline void Exit_DoorFlags::set_noblock(bool value) {
  set_has_noblock();
  noblock_ = value;
}

// optional bool nobreak = 3 [default = false];
inline bool Exit_DoorFlags::has_nobreak() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Exit_DoorFlags::set_has_nobreak() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Exit_DoorFlags::clear_has_nobreak() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Exit_DoorFlags::clear_nobreak() {
  nobreak_ = false;
  clear_has_nobreak();
}
inline bool Exit_DoorFlags::nobreak() const {
  return nobreak_;
}
inline void Exit_DoorFlags::set_nobreak(bool value) {
  set_has_nobreak();
  nobreak_ = value;
}

// optional bool nopick = 4 [default = false];
inline bool Exit_DoorFlags::has_nopick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Exit_DoorFlags::set_has_nopick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Exit_DoorFlags::clear_has_nopick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Exit_DoorFlags::clear_nopick() {
  nopick_ = false;
  clear_has_nopick();
}
inline bool Exit_DoorFlags::nopick() const {
  return nopick_;
}
inline void Exit_DoorFlags::set_nopick(bool value) {
  set_has_nopick();
  nopick_ = value;
}

// optional bool delayed = 5 [default = false];
inline bool Exit_DoorFlags::has_delayed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Exit_DoorFlags::set_has_delayed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Exit_DoorFlags::clear_has_delayed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Exit_DoorFlags::clear_delayed() {
  delayed_ = false;
  clear_has_delayed();
}
inline bool Exit_DoorFlags::delayed() const {
  return delayed_;
}
inline void Exit_DoorFlags::set_delayed(bool value) {
  set_has_delayed();
  delayed_ = value;
}

// -------------------------------------------------------------------

// Exit

// required .mapdata.Exit.ExitDirection dir = 1 [default = ED_UNKNOWN];
inline bool Exit::has_dir() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exit::set_has_dir() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exit::clear_has_dir() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exit::clear_dir() {
  dir_ = 6;
  clear_has_dir();
}
inline ::mapdata::Exit_ExitDirection Exit::dir() const {
  return static_cast< ::mapdata::Exit_ExitDirection >(dir_);
}
inline void Exit::set_dir(::mapdata::Exit_ExitDirection value) {
  assert(::mapdata::Exit_ExitDirection_IsValid(value));
  set_has_dir();
  dir_ = value;
}

// optional int32 leads_to_id = 2 [default = 0];
inline bool Exit::has_leads_to_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exit::set_has_leads_to_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exit::clear_has_leads_to_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exit::clear_leads_to_id() {
  leads_to_id_ = 0;
  clear_has_leads_to_id();
}
inline ::google::protobuf::int32 Exit::leads_to_id() const {
  return leads_to_id_;
}
inline void Exit::set_leads_to_id(::google::protobuf::int32 value) {
  set_has_leads_to_id();
  leads_to_id_ = value;
}

// optional .mapdata.Exit.ExitType type = 3 [default = ET_NONE];
inline bool Exit::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Exit::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Exit::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Exit::clear_type() {
  type_ = 5;
  clear_has_type();
}
inline ::mapdata::Exit_ExitType Exit::type() const {
  return static_cast< ::mapdata::Exit_ExitType >(type_);
}
inline void Exit::set_type(::mapdata::Exit_ExitType value) {
  assert(::mapdata::Exit_ExitType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string door = 4;
inline bool Exit::has_door() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Exit::set_has_door() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Exit::clear_has_door() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Exit::clear_door() {
  if (door_ != &::google::protobuf::internal::kEmptyString) {
    door_->clear();
  }
  clear_has_door();
}
inline const ::std::string& Exit::door() const {
  return *door_;
}
inline void Exit::set_door(const ::std::string& value) {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  door_->assign(value);
}
inline void Exit::set_door(const char* value) {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  door_->assign(value);
}
inline void Exit::set_door(const char* value, size_t size) {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  door_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Exit::mutable_door() {
  set_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    door_ = new ::std::string;
  }
  return door_;
}
inline ::std::string* Exit::release_door() {
  clear_has_door();
  if (door_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = door_;
    door_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Exit::set_allocated_door(::std::string* door) {
  if (door_ != &::google::protobuf::internal::kEmptyString) {
    delete door_;
  }
  if (door) {
    set_has_door();
    door_ = door;
  } else {
    clear_has_door();
    door_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mapdata.Exit.ExitFlags exit_flags = 5;
inline bool Exit::has_exit_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Exit::set_has_exit_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Exit::clear_has_exit_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Exit::clear_exit_flags() {
  if (exit_flags_ != NULL) exit_flags_->::mapdata::Exit_ExitFlags::Clear();
  clear_has_exit_flags();
}
inline const ::mapdata::Exit_ExitFlags& Exit::exit_flags() const {
  return exit_flags_ != NULL ? *exit_flags_ : *default_instance_->exit_flags_;
}
inline ::mapdata::Exit_ExitFlags* Exit::mutable_exit_flags() {
  set_has_exit_flags();
  if (exit_flags_ == NULL) exit_flags_ = new ::mapdata::Exit_ExitFlags;
  return exit_flags_;
}
inline ::mapdata::Exit_ExitFlags* Exit::release_exit_flags() {
  clear_has_exit_flags();
  ::mapdata::Exit_ExitFlags* temp = exit_flags_;
  exit_flags_ = NULL;
  return temp;
}
inline void Exit::set_allocated_exit_flags(::mapdata::Exit_ExitFlags* exit_flags) {
  delete exit_flags_;
  exit_flags_ = exit_flags;
  if (exit_flags) {
    set_has_exit_flags();
  } else {
    clear_has_exit_flags();
  }
}

// optional .mapdata.Exit.DoorFlags door_flags = 6;
inline bool Exit::has_door_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Exit::set_has_door_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Exit::clear_has_door_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Exit::clear_door_flags() {
  if (door_flags_ != NULL) door_flags_->::mapdata::Exit_DoorFlags::Clear();
  clear_has_door_flags();
}
inline const ::mapdata::Exit_DoorFlags& Exit::door_flags() const {
  return door_flags_ != NULL ? *door_flags_ : *default_instance_->door_flags_;
}
inline ::mapdata::Exit_DoorFlags* Exit::mutable_door_flags() {
  set_has_door_flags();
  if (door_flags_ == NULL) door_flags_ = new ::mapdata::Exit_DoorFlags;
  return door_flags_;
}
inline ::mapdata::Exit_DoorFlags* Exit::release_door_flags() {
  clear_has_door_flags();
  ::mapdata::Exit_DoorFlags* temp = door_flags_;
  door_flags_ = NULL;
  return temp;
}
inline void Exit::set_allocated_door_flags(::mapdata::Exit_DoorFlags* door_flags) {
  delete door_flags_;
  door_flags_ = door_flags;
  if (door_flags) {
    set_has_door_flags();
  } else {
    clear_has_door_flags();
  }
}

// -------------------------------------------------------------------

// Room_MobFlags

// optional bool rent = 1 [default = false];
inline bool Room_MobFlags::has_rent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room_MobFlags::set_has_rent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room_MobFlags::clear_has_rent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room_MobFlags::clear_rent() {
  rent_ = false;
  clear_has_rent();
}
inline bool Room_MobFlags::rent() const {
  return rent_;
}
inline void Room_MobFlags::set_rent(bool value) {
  set_has_rent();
  rent_ = value;
}

// optional bool shop = 2 [default = false];
inline bool Room_MobFlags::has_shop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room_MobFlags::set_has_shop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room_MobFlags::clear_has_shop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room_MobFlags::clear_shop() {
  shop_ = false;
  clear_has_shop();
}
inline bool Room_MobFlags::shop() const {
  return shop_;
}
inline void Room_MobFlags::set_shop(bool value) {
  set_has_shop();
  shop_ = value;
}

// optional bool weaponshop = 3 [default = false];
inline bool Room_MobFlags::has_weaponshop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room_MobFlags::set_has_weaponshop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room_MobFlags::clear_has_weaponshop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room_MobFlags::clear_weaponshop() {
  weaponshop_ = false;
  clear_has_weaponshop();
}
inline bool Room_MobFlags::weaponshop() const {
  return weaponshop_;
}
inline void Room_MobFlags::set_weaponshop(bool value) {
  set_has_weaponshop();
  weaponshop_ = value;
}

// optional bool armourshop = 4 [default = false];
inline bool Room_MobFlags::has_armourshop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room_MobFlags::set_has_armourshop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room_MobFlags::clear_has_armourshop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room_MobFlags::clear_armourshop() {
  armourshop_ = false;
  clear_has_armourshop();
}
inline bool Room_MobFlags::armourshop() const {
  return armourshop_;
}
inline void Room_MobFlags::set_armourshop(bool value) {
  set_has_armourshop();
  armourshop_ = value;
}

// optional bool foodshop = 5 [default = false];
inline bool Room_MobFlags::has_foodshop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Room_MobFlags::set_has_foodshop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Room_MobFlags::clear_has_foodshop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Room_MobFlags::clear_foodshop() {
  foodshop_ = false;
  clear_has_foodshop();
}
inline bool Room_MobFlags::foodshop() const {
  return foodshop_;
}
inline void Room_MobFlags::set_foodshop(bool value) {
  set_has_foodshop();
  foodshop_ = value;
}

// optional bool petshop = 6 [default = false];
inline bool Room_MobFlags::has_petshop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Room_MobFlags::set_has_petshop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Room_MobFlags::clear_has_petshop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Room_MobFlags::clear_petshop() {
  petshop_ = false;
  clear_has_petshop();
}
inline bool Room_MobFlags::petshop() const {
  return petshop_;
}
inline void Room_MobFlags::set_petshop(bool value) {
  set_has_petshop();
  petshop_ = value;
}

// optional bool guild = 7 [default = false];
inline bool Room_MobFlags::has_guild() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Room_MobFlags::set_has_guild() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Room_MobFlags::clear_has_guild() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Room_MobFlags::clear_guild() {
  guild_ = false;
  clear_has_guild();
}
inline bool Room_MobFlags::guild() const {
  return guild_;
}
inline void Room_MobFlags::set_guild(bool value) {
  set_has_guild();
  guild_ = value;
}

// optional bool scoutguild = 8 [default = false];
inline bool Room_MobFlags::has_scoutguild() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Room_MobFlags::set_has_scoutguild() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Room_MobFlags::clear_has_scoutguild() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Room_MobFlags::clear_scoutguild() {
  scoutguild_ = false;
  clear_has_scoutguild();
}
inline bool Room_MobFlags::scoutguild() const {
  return scoutguild_;
}
inline void Room_MobFlags::set_scoutguild(bool value) {
  set_has_scoutguild();
  scoutguild_ = value;
}

// optional bool mageguild = 9 [default = false];
inline bool Room_MobFlags::has_mageguild() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Room_MobFlags::set_has_mageguild() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Room_MobFlags::clear_has_mageguild() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Room_MobFlags::clear_mageguild() {
  mageguild_ = false;
  clear_has_mageguild();
}
inline bool Room_MobFlags::mageguild() const {
  return mageguild_;
}
inline void Room_MobFlags::set_mageguild(bool value) {
  set_has_mageguild();
  mageguild_ = value;
}

// optional bool clericguild = 10 [default = false];
inline bool Room_MobFlags::has_clericguild() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Room_MobFlags::set_has_clericguild() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Room_MobFlags::clear_has_clericguild() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Room_MobFlags::clear_clericguild() {
  clericguild_ = false;
  clear_has_clericguild();
}
inline bool Room_MobFlags::clericguild() const {
  return clericguild_;
}
inline void Room_MobFlags::set_clericguild(bool value) {
  set_has_clericguild();
  clericguild_ = value;
}

// optional bool warriorguild = 11 [default = false];
inline bool Room_MobFlags::has_warriorguild() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Room_MobFlags::set_has_warriorguild() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Room_MobFlags::clear_has_warriorguild() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Room_MobFlags::clear_warriorguild() {
  warriorguild_ = false;
  clear_has_warriorguild();
}
inline bool Room_MobFlags::warriorguild() const {
  return warriorguild_;
}
inline void Room_MobFlags::set_warriorguild(bool value) {
  set_has_warriorguild();
  warriorguild_ = value;
}

// optional bool rangerguild = 12 [default = false];
inline bool Room_MobFlags::has_rangerguild() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Room_MobFlags::set_has_rangerguild() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Room_MobFlags::clear_has_rangerguild() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Room_MobFlags::clear_rangerguild() {
  rangerguild_ = false;
  clear_has_rangerguild();
}
inline bool Room_MobFlags::rangerguild() const {
  return rangerguild_;
}
inline void Room_MobFlags::set_rangerguild(bool value) {
  set_has_rangerguild();
  rangerguild_ = value;
}

// optional bool smob = 13 [default = false];
inline bool Room_MobFlags::has_smob() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Room_MobFlags::set_has_smob() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Room_MobFlags::clear_has_smob() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Room_MobFlags::clear_smob() {
  smob_ = false;
  clear_has_smob();
}
inline bool Room_MobFlags::smob() const {
  return smob_;
}
inline void Room_MobFlags::set_smob(bool value) {
  set_has_smob();
  smob_ = value;
}

// optional bool quest = 14 [default = false];
inline bool Room_MobFlags::has_quest() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Room_MobFlags::set_has_quest() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Room_MobFlags::clear_has_quest() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Room_MobFlags::clear_quest() {
  quest_ = false;
  clear_has_quest();
}
inline bool Room_MobFlags::quest() const {
  return quest_;
}
inline void Room_MobFlags::set_quest(bool value) {
  set_has_quest();
  quest_ = value;
}

// optional bool any = 15 [default = false];
inline bool Room_MobFlags::has_any() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Room_MobFlags::set_has_any() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Room_MobFlags::clear_has_any() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Room_MobFlags::clear_any() {
  any_ = false;
  clear_has_any();
}
inline bool Room_MobFlags::any() const {
  return any_;
}
inline void Room_MobFlags::set_any(bool value) {
  set_has_any();
  any_ = value;
}

// -------------------------------------------------------------------

// Room_LoadFlags

// optional bool treasure = 1 [default = false];
inline bool Room_LoadFlags::has_treasure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room_LoadFlags::set_has_treasure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room_LoadFlags::clear_has_treasure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room_LoadFlags::clear_treasure() {
  treasure_ = false;
  clear_has_treasure();
}
inline bool Room_LoadFlags::treasure() const {
  return treasure_;
}
inline void Room_LoadFlags::set_treasure(bool value) {
  set_has_treasure();
  treasure_ = value;
}

// optional bool armour = 2 [default = false];
inline bool Room_LoadFlags::has_armour() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room_LoadFlags::set_has_armour() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room_LoadFlags::clear_has_armour() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room_LoadFlags::clear_armour() {
  armour_ = false;
  clear_has_armour();
}
inline bool Room_LoadFlags::armour() const {
  return armour_;
}
inline void Room_LoadFlags::set_armour(bool value) {
  set_has_armour();
  armour_ = value;
}

// optional bool weapon = 3 [default = false];
inline bool Room_LoadFlags::has_weapon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room_LoadFlags::set_has_weapon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room_LoadFlags::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room_LoadFlags::clear_weapon() {
  weapon_ = false;
  clear_has_weapon();
}
inline bool Room_LoadFlags::weapon() const {
  return weapon_;
}
inline void Room_LoadFlags::set_weapon(bool value) {
  set_has_weapon();
  weapon_ = value;
}

// optional bool water = 4 [default = false];
inline bool Room_LoadFlags::has_water() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room_LoadFlags::set_has_water() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room_LoadFlags::clear_has_water() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room_LoadFlags::clear_water() {
  water_ = false;
  clear_has_water();
}
inline bool Room_LoadFlags::water() const {
  return water_;
}
inline void Room_LoadFlags::set_water(bool value) {
  set_has_water();
  water_ = value;
}

// optional bool food = 5 [default = false];
inline bool Room_LoadFlags::has_food() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Room_LoadFlags::set_has_food() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Room_LoadFlags::clear_has_food() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Room_LoadFlags::clear_food() {
  food_ = false;
  clear_has_food();
}
inline bool Room_LoadFlags::food() const {
  return food_;
}
inline void Room_LoadFlags::set_food(bool value) {
  set_has_food();
  food_ = value;
}

// optional bool herb = 6 [default = false];
inline bool Room_LoadFlags::has_herb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Room_LoadFlags::set_has_herb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Room_LoadFlags::clear_has_herb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Room_LoadFlags::clear_herb() {
  herb_ = false;
  clear_has_herb();
}
inline bool Room_LoadFlags::herb() const {
  return herb_;
}
inline void Room_LoadFlags::set_herb(bool value) {
  set_has_herb();
  herb_ = value;
}

// optional bool key = 7 [default = false];
inline bool Room_LoadFlags::has_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Room_LoadFlags::set_has_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Room_LoadFlags::clear_has_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Room_LoadFlags::clear_key() {
  key_ = false;
  clear_has_key();
}
inline bool Room_LoadFlags::key() const {
  return key_;
}
inline void Room_LoadFlags::set_key(bool value) {
  set_has_key();
  key_ = value;
}

// optional bool mule = 8 [default = false];
inline bool Room_LoadFlags::has_mule() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Room_LoadFlags::set_has_mule() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Room_LoadFlags::clear_has_mule() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Room_LoadFlags::clear_mule() {
  mule_ = false;
  clear_has_mule();
}
inline bool Room_LoadFlags::mule() const {
  return mule_;
}
inline void Room_LoadFlags::set_mule(bool value) {
  set_has_mule();
  mule_ = value;
}

// optional bool horse = 9 [default = false];
inline bool Room_LoadFlags::has_horse() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Room_LoadFlags::set_has_horse() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Room_LoadFlags::clear_has_horse() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Room_LoadFlags::clear_horse() {
  horse_ = false;
  clear_has_horse();
}
inline bool Room_LoadFlags::horse() const {
  return horse_;
}
inline void Room_LoadFlags::set_horse(bool value) {
  set_has_horse();
  horse_ = value;
}

// optional bool packhorse = 10 [default = false];
inline bool Room_LoadFlags::has_packhorse() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Room_LoadFlags::set_has_packhorse() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Room_LoadFlags::clear_has_packhorse() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Room_LoadFlags::clear_packhorse() {
  packhorse_ = false;
  clear_has_packhorse();
}
inline bool Room_LoadFlags::packhorse() const {
  return packhorse_;
}
inline void Room_LoadFlags::set_packhorse(bool value) {
  set_has_packhorse();
  packhorse_ = value;
}

// optional bool trainedhorse = 11 [default = false];
inline bool Room_LoadFlags::has_trainedhorse() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Room_LoadFlags::set_has_trainedhorse() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Room_LoadFlags::clear_has_trainedhorse() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Room_LoadFlags::clear_trainedhorse() {
  trainedhorse_ = false;
  clear_has_trainedhorse();
}
inline bool Room_LoadFlags::trainedhorse() const {
  return trainedhorse_;
}
inline void Room_LoadFlags::set_trainedhorse(bool value) {
  set_has_trainedhorse();
  trainedhorse_ = value;
}

// optional bool rohirrim = 12 [default = false];
inline bool Room_LoadFlags::has_rohirrim() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Room_LoadFlags::set_has_rohirrim() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Room_LoadFlags::clear_has_rohirrim() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Room_LoadFlags::clear_rohirrim() {
  rohirrim_ = false;
  clear_has_rohirrim();
}
inline bool Room_LoadFlags::rohirrim() const {
  return rohirrim_;
}
inline void Room_LoadFlags::set_rohirrim(bool value) {
  set_has_rohirrim();
  rohirrim_ = value;
}

// optional bool warg = 13 [default = false];
inline bool Room_LoadFlags::has_warg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Room_LoadFlags::set_has_warg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Room_LoadFlags::clear_has_warg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Room_LoadFlags::clear_warg() {
  warg_ = false;
  clear_has_warg();
}
inline bool Room_LoadFlags::warg() const {
  return warg_;
}
inline void Room_LoadFlags::set_warg(bool value) {
  set_has_warg();
  warg_ = value;
}

// optional bool boat = 14 [default = false];
inline bool Room_LoadFlags::has_boat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Room_LoadFlags::set_has_boat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Room_LoadFlags::clear_has_boat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Room_LoadFlags::clear_boat() {
  boat_ = false;
  clear_has_boat();
}
inline bool Room_LoadFlags::boat() const {
  return boat_;
}
inline void Room_LoadFlags::set_boat(bool value) {
  set_has_boat();
  boat_ = value;
}

// optional bool attention = 15 [default = false];
inline bool Room_LoadFlags::has_attention() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Room_LoadFlags::set_has_attention() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Room_LoadFlags::clear_has_attention() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Room_LoadFlags::clear_attention() {
  attention_ = false;
  clear_has_attention();
}
inline bool Room_LoadFlags::attention() const {
  return attention_;
}
inline void Room_LoadFlags::set_attention(bool value) {
  set_has_attention();
  attention_ = value;
}

// optional bool tower = 16 [default = false];
inline bool Room_LoadFlags::has_tower() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Room_LoadFlags::set_has_tower() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Room_LoadFlags::clear_has_tower() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Room_LoadFlags::clear_tower() {
  tower_ = false;
  clear_has_tower();
}
inline bool Room_LoadFlags::tower() const {
  return tower_;
}
inline void Room_LoadFlags::set_tower(bool value) {
  set_has_tower();
  tower_ = value;
}

// -------------------------------------------------------------------

// Room_Coordinate

// required float x = 1;
inline bool Room_Coordinate::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room_Coordinate::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room_Coordinate::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room_Coordinate::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Room_Coordinate::x() const {
  return x_;
}
inline void Room_Coordinate::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Room_Coordinate::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room_Coordinate::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room_Coordinate::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room_Coordinate::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Room_Coordinate::y() const {
  return y_;
}
inline void Room_Coordinate::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool Room_Coordinate::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room_Coordinate::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room_Coordinate::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room_Coordinate::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Room_Coordinate::z() const {
  return z_;
}
inline void Room_Coordinate::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional float scale = 4 [default = 1];
inline bool Room_Coordinate::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room_Coordinate::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room_Coordinate::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room_Coordinate::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float Room_Coordinate::scale() const {
  return scale_;
}
inline void Room_Coordinate::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// -------------------------------------------------------------------

// Room

// required int32 id = 1;
inline bool Room::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Room::id() const {
  return id_;
}
inline void Room::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2 [default = ""];
inline bool Room::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Room::name() const {
  return *name_;
}
inline void Room::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Room::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Room::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Room::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Room::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 3 [default = ""];
inline bool Room::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Room::desc() const {
  return *desc_;
}
inline void Room::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Room::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Room::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* Room::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Room::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .mapdata.Room.Coordinate pos = 4;
inline bool Room::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room::clear_pos() {
  if (pos_ != NULL) pos_->::mapdata::Room_Coordinate::Clear();
  clear_has_pos();
}
inline const ::mapdata::Room_Coordinate& Room::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::mapdata::Room_Coordinate* Room::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::mapdata::Room_Coordinate;
  return pos_;
}
inline ::mapdata::Room_Coordinate* Room::release_pos() {
  clear_has_pos();
  ::mapdata::Room_Coordinate* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void Room::set_allocated_pos(::mapdata::Room_Coordinate* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional string area_name = 6 [default = "default"];
inline bool Room::has_area_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Room::set_has_area_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Room::clear_has_area_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Room::clear_area_name() {
  if (area_name_ != _default_area_name_) {
    area_name_->assign(*_default_area_name_);
  }
  clear_has_area_name();
}
inline const ::std::string& Room::area_name() const {
  return *area_name_;
}
inline void Room::set_area_name(const ::std::string& value) {
  set_has_area_name();
  if (area_name_ == _default_area_name_) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void Room::set_area_name(const char* value) {
  set_has_area_name();
  if (area_name_ == _default_area_name_) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void Room::set_area_name(const char* value, size_t size) {
  set_has_area_name();
  if (area_name_ == _default_area_name_) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_area_name() {
  set_has_area_name();
  if (area_name_ == _default_area_name_) {
    area_name_ = new ::std::string(*_default_area_name_);
  }
  return area_name_;
}
inline ::std::string* Room::release_area_name() {
  clear_has_area_name();
  if (area_name_ == _default_area_name_) {
    return NULL;
  } else {
    ::std::string* temp = area_name_;
    area_name_ = const_cast< ::std::string*>(_default_area_name_);
    return temp;
  }
}
inline void Room::set_allocated_area_name(::std::string* area_name) {
  if (area_name_ != _default_area_name_) {
    delete area_name_;
  }
  if (area_name) {
    set_has_area_name();
    area_name_ = area_name;
  } else {
    clear_has_area_name();
    area_name_ = const_cast< ::std::string*>(_default_area_name_);
  }
}

// optional string dynamicDesc = 7;
inline bool Room::has_dynamicdesc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Room::set_has_dynamicdesc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Room::clear_has_dynamicdesc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Room::clear_dynamicdesc() {
  if (dynamicdesc_ != &::google::protobuf::internal::kEmptyString) {
    dynamicdesc_->clear();
  }
  clear_has_dynamicdesc();
}
inline const ::std::string& Room::dynamicdesc() const {
  return *dynamicdesc_;
}
inline void Room::set_dynamicdesc(const ::std::string& value) {
  set_has_dynamicdesc();
  if (dynamicdesc_ == &::google::protobuf::internal::kEmptyString) {
    dynamicdesc_ = new ::std::string;
  }
  dynamicdesc_->assign(value);
}
inline void Room::set_dynamicdesc(const char* value) {
  set_has_dynamicdesc();
  if (dynamicdesc_ == &::google::protobuf::internal::kEmptyString) {
    dynamicdesc_ = new ::std::string;
  }
  dynamicdesc_->assign(value);
}
inline void Room::set_dynamicdesc(const char* value, size_t size) {
  set_has_dynamicdesc();
  if (dynamicdesc_ == &::google::protobuf::internal::kEmptyString) {
    dynamicdesc_ = new ::std::string;
  }
  dynamicdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_dynamicdesc() {
  set_has_dynamicdesc();
  if (dynamicdesc_ == &::google::protobuf::internal::kEmptyString) {
    dynamicdesc_ = new ::std::string;
  }
  return dynamicdesc_;
}
inline ::std::string* Room::release_dynamicdesc() {
  clear_has_dynamicdesc();
  if (dynamicdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dynamicdesc_;
    dynamicdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Room::set_allocated_dynamicdesc(::std::string* dynamicdesc) {
  if (dynamicdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete dynamicdesc_;
  }
  if (dynamicdesc) {
    set_has_dynamicdesc();
    dynamicdesc_ = dynamicdesc;
  } else {
    clear_has_dynamicdesc();
    dynamicdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mapdata.Room.RoomTerrainType terrain = 8 [default = RTT_UNDEFINED];
inline bool Room::has_terrain() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Room::set_has_terrain() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Room::clear_has_terrain() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Room::clear_terrain() {
  terrain_ = 0;
  clear_has_terrain();
}
inline ::mapdata::Room_RoomTerrainType Room::terrain() const {
  return static_cast< ::mapdata::Room_RoomTerrainType >(terrain_);
}
inline void Room::set_terrain(::mapdata::Room_RoomTerrainType value) {
  assert(::mapdata::Room_RoomTerrainType_IsValid(value));
  set_has_terrain();
  terrain_ = value;
}

// repeated .mapdata.Exit exits = 9;
inline int Room::exits_size() const {
  return exits_.size();
}
inline void Room::clear_exits() {
  exits_.Clear();
}
inline const ::mapdata::Exit& Room::exits(int index) const {
  return exits_.Get(index);
}
inline ::mapdata::Exit* Room::mutable_exits(int index) {
  return exits_.Mutable(index);
}
inline ::mapdata::Exit* Room::add_exits() {
  return exits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mapdata::Exit >&
Room::exits() const {
  return exits_;
}
inline ::google::protobuf::RepeatedPtrField< ::mapdata::Exit >*
Room::mutable_exits() {
  return &exits_;
}

// optional string note = 15;
inline bool Room::has_note() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Room::set_has_note() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Room::clear_has_note() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Room::clear_note() {
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    note_->clear();
  }
  clear_has_note();
}
inline const ::std::string& Room::note() const {
  return *note_;
}
inline void Room::set_note(const ::std::string& value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void Room::set_note(const char* value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void Room::set_note(const char* value, size_t size) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_note() {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  return note_;
}
inline ::std::string* Room::release_note() {
  clear_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = note_;
    note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Room::set_allocated_note(::std::string* note) {
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    delete note_;
  }
  if (note) {
    set_has_note();
    note_ = note;
  } else {
    clear_has_note();
    note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string note_color = 16;
inline bool Room::has_note_color() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Room::set_has_note_color() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Room::clear_has_note_color() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Room::clear_note_color() {
  if (note_color_ != &::google::protobuf::internal::kEmptyString) {
    note_color_->clear();
  }
  clear_has_note_color();
}
inline const ::std::string& Room::note_color() const {
  return *note_color_;
}
inline void Room::set_note_color(const ::std::string& value) {
  set_has_note_color();
  if (note_color_ == &::google::protobuf::internal::kEmptyString) {
    note_color_ = new ::std::string;
  }
  note_color_->assign(value);
}
inline void Room::set_note_color(const char* value) {
  set_has_note_color();
  if (note_color_ == &::google::protobuf::internal::kEmptyString) {
    note_color_ = new ::std::string;
  }
  note_color_->assign(value);
}
inline void Room::set_note_color(const char* value, size_t size) {
  set_has_note_color();
  if (note_color_ == &::google::protobuf::internal::kEmptyString) {
    note_color_ = new ::std::string;
  }
  note_color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_note_color() {
  set_has_note_color();
  if (note_color_ == &::google::protobuf::internal::kEmptyString) {
    note_color_ = new ::std::string;
  }
  return note_color_;
}
inline ::std::string* Room::release_note_color() {
  clear_has_note_color();
  if (note_color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = note_color_;
    note_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Room::set_allocated_note_color(::std::string* note_color) {
  if (note_color_ != &::google::protobuf::internal::kEmptyString) {
    delete note_color_;
  }
  if (note_color) {
    set_has_note_color();
    note_color_ = note_color;
  } else {
    clear_has_note_color();
    note_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string info = 17;
inline bool Room::has_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Room::set_has_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Room::clear_has_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Room::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& Room::info() const {
  return *info_;
}
inline void Room::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void Room::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void Room::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Room::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* Room::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Room::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .mapdata.Room.RoomPortableType flag_portable = 18 [default = RPT_UNDEFINED];
inline bool Room::has_flag_portable() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Room::set_has_flag_portable() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Room::clear_has_flag_portable() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Room::clear_flag_portable() {
  flag_portable_ = 0;
  clear_has_flag_portable();
}
inline ::mapdata::Room_RoomPortableType Room::flag_portable() const {
  return static_cast< ::mapdata::Room_RoomPortableType >(flag_portable_);
}
inline void Room::set_flag_portable(::mapdata::Room_RoomPortableType value) {
  assert(::mapdata::Room_RoomPortableType_IsValid(value));
  set_has_flag_portable();
  flag_portable_ = value;
}

// optional .mapdata.Room.RoomLightType flag_light = 19 [default = RLT_UNDEFINED];
inline bool Room::has_flag_light() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Room::set_has_flag_light() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Room::clear_has_flag_light() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Room::clear_flag_light() {
  flag_light_ = 0;
  clear_has_flag_light();
}
inline ::mapdata::Room_RoomLightType Room::flag_light() const {
  return static_cast< ::mapdata::Room_RoomLightType >(flag_light_);
}
inline void Room::set_flag_light(::mapdata::Room_RoomLightType value) {
  assert(::mapdata::Room_RoomLightType_IsValid(value));
  set_has_flag_light();
  flag_light_ = value;
}

// optional .mapdata.Room.RoomRidableType flag_rideable = 20 [default = RRT_UNDEFINED];
inline bool Room::has_flag_rideable() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Room::set_has_flag_rideable() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Room::clear_has_flag_rideable() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Room::clear_flag_rideable() {
  flag_rideable_ = 0;
  clear_has_flag_rideable();
}
inline ::mapdata::Room_RoomRidableType Room::flag_rideable() const {
  return static_cast< ::mapdata::Room_RoomRidableType >(flag_rideable_);
}
inline void Room::set_flag_rideable(::mapdata::Room_RoomRidableType value) {
  assert(::mapdata::Room_RoomRidableType_IsValid(value));
  set_has_flag_rideable();
  flag_rideable_ = value;
}

// optional .mapdata.Room.RoomAlignType flag_align = 21 [default = RAT_UNDEFINED];
inline bool Room::has_flag_align() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Room::set_has_flag_align() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Room::clear_has_flag_align() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Room::clear_flag_align() {
  flag_align_ = 0;
  clear_has_flag_align();
}
inline ::mapdata::Room_RoomAlignType Room::flag_align() const {
  return static_cast< ::mapdata::Room_RoomAlignType >(flag_align_);
}
inline void Room::set_flag_align(::mapdata::Room_RoomAlignType value) {
  assert(::mapdata::Room_RoomAlignType_IsValid(value));
  set_has_flag_align();
  flag_align_ = value;
}

// optional .mapdata.Room.MobFlags mob_flags = 22;
inline bool Room::has_mob_flags() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Room::set_has_mob_flags() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Room::clear_has_mob_flags() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Room::clear_mob_flags() {
  if (mob_flags_ != NULL) mob_flags_->::mapdata::Room_MobFlags::Clear();
  clear_has_mob_flags();
}
inline const ::mapdata::Room_MobFlags& Room::mob_flags() const {
  return mob_flags_ != NULL ? *mob_flags_ : *default_instance_->mob_flags_;
}
inline ::mapdata::Room_MobFlags* Room::mutable_mob_flags() {
  set_has_mob_flags();
  if (mob_flags_ == NULL) mob_flags_ = new ::mapdata::Room_MobFlags;
  return mob_flags_;
}
inline ::mapdata::Room_MobFlags* Room::release_mob_flags() {
  clear_has_mob_flags();
  ::mapdata::Room_MobFlags* temp = mob_flags_;
  mob_flags_ = NULL;
  return temp;
}
inline void Room::set_allocated_mob_flags(::mapdata::Room_MobFlags* mob_flags) {
  delete mob_flags_;
  mob_flags_ = mob_flags;
  if (mob_flags) {
    set_has_mob_flags();
  } else {
    clear_has_mob_flags();
  }
}

// optional .mapdata.Room.LoadFlags load_flags = 23;
inline bool Room::has_load_flags() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Room::set_has_load_flags() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Room::clear_has_load_flags() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Room::clear_load_flags() {
  if (load_flags_ != NULL) load_flags_->::mapdata::Room_LoadFlags::Clear();
  clear_has_load_flags();
}
inline const ::mapdata::Room_LoadFlags& Room::load_flags() const {
  return load_flags_ != NULL ? *load_flags_ : *default_instance_->load_flags_;
}
inline ::mapdata::Room_LoadFlags* Room::mutable_load_flags() {
  set_has_load_flags();
  if (load_flags_ == NULL) load_flags_ = new ::mapdata::Room_LoadFlags;
  return load_flags_;
}
inline ::mapdata::Room_LoadFlags* Room::release_load_flags() {
  clear_has_load_flags();
  ::mapdata::Room_LoadFlags* temp = load_flags_;
  load_flags_ = NULL;
  return temp;
}
inline void Room::set_allocated_load_flags(::mapdata::Room_LoadFlags* load_flags) {
  delete load_flags_;
  load_flags_ = load_flags;
  if (load_flags) {
    set_has_load_flags();
  } else {
    clear_has_load_flags();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mapdata

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mapdata::Exit_ExitType>() {
  return ::mapdata::Exit_ExitType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mapdata::Exit_ExitDirection>() {
  return ::mapdata::Exit_ExitDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mapdata::Room_RoomTerrainType>() {
  return ::mapdata::Room_RoomTerrainType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mapdata::Room_RoomPortableType>() {
  return ::mapdata::Room_RoomPortableType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mapdata::Room_RoomLightType>() {
  return ::mapdata::Room_RoomLightType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mapdata::Room_RoomAlignType>() {
  return ::mapdata::Room_RoomAlignType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mapdata::Room_RoomRidableType>() {
  return ::mapdata::Room_RoomRidableType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_map_2eproto__INCLUDED
