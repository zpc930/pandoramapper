// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "map.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mapdata {

namespace {

const ::google::protobuf::Descriptor* MapHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* Area_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Area_reflection_ = NULL;
const ::google::protobuf::Descriptor* Area_Alias_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Area_Alias_reflection_ = NULL;
const ::google::protobuf::Descriptor* Exit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Exit_reflection_ = NULL;
const ::google::protobuf::Descriptor* Exit_ExitFlags_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Exit_ExitFlags_reflection_ = NULL;
const ::google::protobuf::Descriptor* Exit_DoorFlags_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Exit_DoorFlags_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Exit_ExitType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Exit_ExitDirection_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Room_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Room_reflection_ = NULL;
const ::google::protobuf::Descriptor* Room_MobFlags_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Room_MobFlags_reflection_ = NULL;
const ::google::protobuf::Descriptor* Room_LoadFlags_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Room_LoadFlags_reflection_ = NULL;
const ::google::protobuf::Descriptor* Room_Coordinate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Room_Coordinate_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Room_RoomTerrainType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Room_RoomPortableType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Room_RoomLightType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Room_RoomAlignType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Room_RoomRidableType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_map_2eproto() {
  protobuf_AddDesc_map_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "map.proto");
  GOOGLE_CHECK(file != NULL);
  MapHeader_descriptor_ = file->message_type(0);
  static const int MapHeader_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapHeader, rooms_amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapHeader, areas_amount_),
  };
  MapHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapHeader_descriptor_,
      MapHeader::default_instance_,
      MapHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapHeader));
  Area_descriptor_ = file->message_type(1);
  static const int Area_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, alias_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, scale_),
  };
  Area_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Area_descriptor_,
      Area::default_instance_,
      Area_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Area));
  Area_Alias_descriptor_ = Area_descriptor_->nested_type(0);
  static const int Area_Alias_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area_Alias, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area_Alias, door_),
  };
  Area_Alias_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Area_Alias_descriptor_,
      Area_Alias::default_instance_,
      Area_Alias_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area_Alias, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Area_Alias, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Area_Alias));
  Exit_descriptor_ = file->message_type(2);
  static const int Exit_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, dir_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, leads_to_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, door_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, exit_flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, door_flags_),
  };
  Exit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Exit_descriptor_,
      Exit::default_instance_,
      Exit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Exit));
  Exit_ExitFlags_descriptor_ = Exit_descriptor_->nested_type(0);
  static const int Exit_ExitFlags_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, exit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, door_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, road_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, climb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, random_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, special_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, no_match_),
  };
  Exit_ExitFlags_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Exit_ExitFlags_descriptor_,
      Exit_ExitFlags::default_instance_,
      Exit_ExitFlags_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_ExitFlags, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Exit_ExitFlags));
  Exit_DoorFlags_descriptor_ = Exit_descriptor_->nested_type(1);
  static const int Exit_DoorFlags_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, hidden_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, needkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, noblock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, nobreak_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, nopick_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, delayed_),
  };
  Exit_DoorFlags_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Exit_DoorFlags_descriptor_,
      Exit_DoorFlags::default_instance_,
      Exit_DoorFlags_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Exit_DoorFlags, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Exit_DoorFlags));
  Exit_ExitType_descriptor_ = Exit_descriptor_->enum_type(0);
  Exit_ExitDirection_descriptor_ = Exit_descriptor_->enum_type(1);
  Room_descriptor_ = file->message_type(3);
  static const int Room_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, desc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, area_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, dynamicdesc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, terrain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, exits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, note_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, note_color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, flag_portable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, flag_light_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, flag_rideable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, flag_align_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, mob_flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, load_flags_),
  };
  Room_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Room_descriptor_,
      Room::default_instance_,
      Room_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Room));
  Room_MobFlags_descriptor_ = Room_descriptor_->nested_type(0);
  static const int Room_MobFlags_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, rent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, shop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, weaponshop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, armourshop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, foodshop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, petshop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, guild_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, scoutguild_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, mageguild_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, clericguild_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, warriorguild_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, rangerguild_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, smob_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, quest_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, any_),
  };
  Room_MobFlags_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Room_MobFlags_descriptor_,
      Room_MobFlags::default_instance_,
      Room_MobFlags_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_MobFlags, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Room_MobFlags));
  Room_LoadFlags_descriptor_ = Room_descriptor_->nested_type(1);
  static const int Room_LoadFlags_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, treasure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, armour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, weapon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, water_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, food_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, herb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, mule_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, horse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, packhorse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, trainedhorse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, rohirrim_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, warg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, boat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, attention_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, tower_),
  };
  Room_LoadFlags_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Room_LoadFlags_descriptor_,
      Room_LoadFlags::default_instance_,
      Room_LoadFlags_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_LoadFlags, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Room_LoadFlags));
  Room_Coordinate_descriptor_ = Room_descriptor_->nested_type(2);
  static const int Room_Coordinate_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_Coordinate, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_Coordinate, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_Coordinate, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_Coordinate, scale_),
  };
  Room_Coordinate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Room_Coordinate_descriptor_,
      Room_Coordinate::default_instance_,
      Room_Coordinate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_Coordinate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Room_Coordinate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Room_Coordinate));
  Room_RoomTerrainType_descriptor_ = Room_descriptor_->enum_type(0);
  Room_RoomPortableType_descriptor_ = Room_descriptor_->enum_type(1);
  Room_RoomLightType_descriptor_ = Room_descriptor_->enum_type(2);
  Room_RoomAlignType_descriptor_ = Room_descriptor_->enum_type(3);
  Room_RoomRidableType_descriptor_ = Room_descriptor_->enum_type(4);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_map_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapHeader_descriptor_, &MapHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Area_descriptor_, &Area::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Area_Alias_descriptor_, &Area_Alias::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Exit_descriptor_, &Exit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Exit_ExitFlags_descriptor_, &Exit_ExitFlags::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Exit_DoorFlags_descriptor_, &Exit_DoorFlags::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Room_descriptor_, &Room::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Room_MobFlags_descriptor_, &Room_MobFlags::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Room_LoadFlags_descriptor_, &Room_LoadFlags::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Room_Coordinate_descriptor_, &Room_Coordinate::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_map_2eproto() {
  delete MapHeader::default_instance_;
  delete MapHeader_reflection_;
  delete Area::default_instance_;
  delete Area_reflection_;
  delete Area_Alias::default_instance_;
  delete Area_Alias_reflection_;
  delete Exit::default_instance_;
  delete Exit_reflection_;
  delete Exit_ExitFlags::default_instance_;
  delete Exit_ExitFlags_reflection_;
  delete Exit_DoorFlags::default_instance_;
  delete Exit_DoorFlags_reflection_;
  delete Room::default_instance_;
  delete Room_reflection_;
  delete Room::_default_area_name_;
  delete Room_MobFlags::default_instance_;
  delete Room_MobFlags_reflection_;
  delete Room_LoadFlags::default_instance_;
  delete Room_LoadFlags_reflection_;
  delete Room_Coordinate::default_instance_;
  delete Room_Coordinate_reflection_;
}

void protobuf_AddDesc_map_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tmap.proto\022\007mapdata\"=\n\tMapHeader\022\027\n\014roo"
    "ms_amount\030\001 \001(\005:\0010\022\027\n\014areas_amount\030\002 \001(\005"
    ":\0010\"o\n\004Area\022\014\n\004name\030\001 \002(\t\022\"\n\005alias\030\002 \003(\013"
    "2\023.mapdata.Area.Alias\022\020\n\005scale\030\003 \001(\002:\0011\032"
    "#\n\005Alias\022\014\n\004name\030\001 \002(\t\022\014\n\004door\030\002 \002(\t\"\202\006\n"
    "\004Exit\0224\n\003dir\030\001 \002(\0162\033.mapdata.Exit.ExitDi"
    "rection:\nED_UNKNOWN\022\023\n\013leads_to_id\030\002 \001(\005"
    "\022-\n\004type\030\003 \001(\0162\026.mapdata.Exit.ExitType:\007"
    "ET_NONE\022\014\n\004door\030\004 \001(\t\022+\n\nexit_flags\030\005 \001("
    "\0132\027.mapdata.Exit.ExitFlags\022+\n\ndoor_flags"
    "\030\006 \001(\0132\027.mapdata.Exit.DoorFlags\032\250\001\n\tExit"
    "Flags\022\023\n\004exit\030\001 \001(\010:\005false\022\023\n\004door\030\002 \001(\010"
    ":\005false\022\023\n\004road\030\003 \001(\010:\005false\022\024\n\005climb\030\004 "
    "\001(\010:\005false\022\025\n\006random\030\005 \001(\010:\005false\022\026\n\007spe"
    "cial\030\006 \001(\010:\005false\022\027\n\010no_match\030\007 \001(\010:\005fal"
    "se\032\231\001\n\tDoorFlags\022\025\n\006hidden\030\001 \001(\010:\005false\022"
    "\026\n\007needkey\030\002 \001(\010:\005false\022\026\n\007noblock\030\003 \001(\010"
    ":\005false\022\026\n\007nobreak\030\004 \001(\010:\005false\022\025\n\006nopic"
    "k\030\005 \001(\010:\005false\022\026\n\007delayed\030\006 \001(\010:\005false\"b"
    "\n\010ExitType\022\r\n\tET_NORMAL\020\000\022\013\n\007ET_LOOP\020\001\022\r"
    "\n\tET_ONEWAY\020\002\022\020\n\014ET_UNDEFINED\020\003\022\014\n\010ET_DE"
    "ATH\020\004\022\013\n\007ET_NONE\020\005\"m\n\rExitDirection\022\014\n\010E"
    "D_NORTH\020\000\022\014\n\010ED_SOUTH\020\001\022\013\n\007ED_EAST\020\002\022\013\n\007"
    "ED_WEST\020\003\022\t\n\005ED_UP\020\004\022\013\n\007ED_DOWN\020\005\022\016\n\nED_"
    "UNKNOWN\020\006\"\206\020\n\004Room\022\n\n\002id\030\001 \002(\005\022\014\n\004name\030\002"
    " \002(\t\022\014\n\004desc\030\003 \002(\t\022%\n\003pos\030\004 \002(\0132\030.mapdat"
    "a.Room.Coordinate\022\032\n\tarea_name\030\006 \001(\t:\007de"
    "fault\022\023\n\013dynamicDesc\030\007 \001(\t\022=\n\007terrain\030\010 "
    "\001(\0162\035.mapdata.Room.RoomTerrainType:\rRTT_"
    "UNDEFINED\022\034\n\005exits\030\t \003(\0132\r.mapdata.Exit\022"
    "\014\n\004note\030\017 \001(\t\022\022\n\nnote_color\030\020 \001(\t\022\014\n\004inf"
    "o\030\021 \001(\t\022D\n\rflag_portable\030\022 \001(\0162\036.mapdata"
    ".Room.RoomPortableType:\rRPT_UNDEFINED\022>\n"
    "\nflag_light\030\023 \001(\0162\033.mapdata.Room.RoomLig"
    "htType:\rRLT_UNDEFINED\022C\n\rflag_rideable\030\024"
    " \001(\0162\035.mapdata.Room.RoomRidableType:\rRRT"
    "_UNDEFINED\022>\n\nflag_align\030\025 \001(\0162\033.mapdata"
    ".Room.RoomAlignType:\rRAT_UNDEFINED\022)\n\tmo"
    "b_flags\030\026 \001(\0132\026.mapdata.Room.MobFlags\022+\n"
    "\nload_flags\030\027 \001(\0132\027.mapdata.Room.LoadFla"
    "gs\032\372\002\n\010MobFlags\022\023\n\004rent\030\001 \001(\010:\005false\022\023\n\004"
    "shop\030\002 \001(\010:\005false\022\031\n\nweaponshop\030\003 \001(\010:\005f"
    "alse\022\031\n\narmourshop\030\004 \001(\010:\005false\022\027\n\010foods"
    "hop\030\005 \001(\010:\005false\022\026\n\007petshop\030\006 \001(\010:\005false"
    "\022\024\n\005guild\030\007 \001(\010:\005false\022\031\n\nscoutguild\030\010 \001"
    "(\010:\005false\022\030\n\tmageguild\030\t \001(\010:\005false\022\032\n\013c"
    "lericguild\030\n \001(\010:\005false\022\033\n\014warriorguild\030"
    "\013 \001(\010:\005false\022\032\n\013rangerguild\030\014 \001(\010:\005false"
    "\022\023\n\004smob\030\r \001(\010:\005false\022\024\n\005quest\030\016 \001(\010:\005fa"
    "lse\022\022\n\003any\030\017 \001(\010:\005false\032\373\002\n\tLoadFlags\022\027\n"
    "\010treasure\030\001 \001(\010:\005false\022\025\n\006armour\030\002 \001(\010:\005"
    "false\022\025\n\006weapon\030\003 \001(\010:\005false\022\024\n\005water\030\004 "
    "\001(\010:\005false\022\023\n\004food\030\005 \001(\010:\005false\022\023\n\004herb\030"
    "\006 \001(\010:\005false\022\022\n\003key\030\007 \001(\010:\005false\022\023\n\004mule"
    "\030\010 \001(\010:\005false\022\024\n\005horse\030\t \001(\010:\005false\022\030\n\tp"
    "ackhorse\030\n \001(\010:\005false\022\033\n\014trainedhorse\030\013 "
    "\001(\010:\005false\022\027\n\010rohirrim\030\014 \001(\010:\005false\022\023\n\004w"
    "arg\030\r \001(\010:\005false\022\023\n\004boat\030\016 \001(\010:\005false\022\030\n"
    "\tattention\030\017 \001(\010:\005false\022\024\n\005tower\030\020 \001(\010:\005"
    "false\032\?\n\nCoordinate\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002("
    "\002\022\t\n\001z\030\003 \002(\002\022\020\n\005scale\030\004 \001(\002:\0011\"\250\002\n\017RoomT"
    "errainType\022\021\n\rRTT_UNDEFINED\020\000\022\017\n\013RTT_IND"
    "OORS\020\001\022\014\n\010RTT_CITY\020\002\022\r\n\tRTT_FIELD\020\003\022\016\n\nR"
    "TT_FOREST\020\004\022\r\n\tRTT_HILLS\020\005\022\021\n\rRTT_MOUNTA"
    "INS\020\006\022\017\n\013RTT_SHALLOW\020\007\022\r\n\tRTT_WATER\020\010\022\016\n"
    "\nRTT_RAPIDS\020\t\022\022\n\016RTT_UNDERWATER\020\n\022\014\n\010RTT"
    "_ROAD\020\013\022\r\n\tRTT_BRUSH\020\014\022\016\n\nRTT_TUNNEL\020\r\022\016"
    "\n\nRTT_CAVERN\020\016\022\021\n\rRTT_DEATHTRAP\020\017\022\016\n\nRTT"
    "_RANDOM\020\020\"L\n\020RoomPortableType\022\021\n\rRPT_UND"
    "EFINED\020\000\022\020\n\014RPT_PORTABLE\020\001\022\023\n\017RPT_NOTPOR"
    "TABLE\020\002\"=\n\rRoomLightType\022\021\n\rRLT_UNDEFINE"
    "D\020\000\022\014\n\010RLT_DARK\020\001\022\013\n\007RLT_LIT\020\002\"O\n\rRoomAl"
    "ignType\022\021\n\rRAT_UNDEFINED\020\000\022\014\n\010RAT_GOOD\020\001"
    "\022\017\n\013RAT_NEUTRAL\020\002\022\014\n\010RAT_EVIL\020\003\"I\n\017RoomR"
    "idableType\022\021\n\rRRT_UNDEFINED\020\000\022\017\n\013RRT_RID"
    "ABLE\020\001\022\022\n\016RRT_NOTRIDABLE\020\002", 3026);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "map.proto", &protobuf_RegisterTypes);
  MapHeader::default_instance_ = new MapHeader();
  Area::default_instance_ = new Area();
  Area_Alias::default_instance_ = new Area_Alias();
  Exit::default_instance_ = new Exit();
  Exit_ExitFlags::default_instance_ = new Exit_ExitFlags();
  Exit_DoorFlags::default_instance_ = new Exit_DoorFlags();
  Room::_default_area_name_ =
      new ::std::string("default", 7);
  Room::default_instance_ = new Room();
  Room_MobFlags::default_instance_ = new Room_MobFlags();
  Room_LoadFlags::default_instance_ = new Room_LoadFlags();
  Room_Coordinate::default_instance_ = new Room_Coordinate();
  MapHeader::default_instance_->InitAsDefaultInstance();
  Area::default_instance_->InitAsDefaultInstance();
  Area_Alias::default_instance_->InitAsDefaultInstance();
  Exit::default_instance_->InitAsDefaultInstance();
  Exit_ExitFlags::default_instance_->InitAsDefaultInstance();
  Exit_DoorFlags::default_instance_->InitAsDefaultInstance();
  Room::default_instance_->InitAsDefaultInstance();
  Room_MobFlags::default_instance_->InitAsDefaultInstance();
  Room_LoadFlags::default_instance_->InitAsDefaultInstance();
  Room_Coordinate::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_map_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_map_2eproto {
  StaticDescriptorInitializer_map_2eproto() {
    protobuf_AddDesc_map_2eproto();
  }
} static_descriptor_initializer_map_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int MapHeader::kRoomsAmountFieldNumber;
const int MapHeader::kAreasAmountFieldNumber;
#endif  // !_MSC_VER

MapHeader::MapHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapHeader::InitAsDefaultInstance() {
}

MapHeader::MapHeader(const MapHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapHeader::SharedCtor() {
  _cached_size_ = 0;
  rooms_amount_ = 0;
  areas_amount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapHeader::~MapHeader() {
  SharedDtor();
}

void MapHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapHeader_descriptor_;
}

const MapHeader& MapHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

MapHeader* MapHeader::default_instance_ = NULL;

MapHeader* MapHeader::New() const {
  return new MapHeader;
}

void MapHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rooms_amount_ = 0;
    areas_amount_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 rooms_amount = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rooms_amount_)));
          set_has_rooms_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_areas_amount;
        break;
      }

      // optional int32 areas_amount = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_areas_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &areas_amount_)));
          set_has_areas_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 rooms_amount = 1 [default = 0];
  if (has_rooms_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->rooms_amount(), output);
  }

  // optional int32 areas_amount = 2 [default = 0];
  if (has_areas_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->areas_amount(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 rooms_amount = 1 [default = 0];
  if (has_rooms_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->rooms_amount(), target);
  }

  // optional int32 areas_amount = 2 [default = 0];
  if (has_areas_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->areas_amount(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 rooms_amount = 1 [default = 0];
    if (has_rooms_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rooms_amount());
    }

    // optional int32 areas_amount = 2 [default = 0];
    if (has_areas_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->areas_amount());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapHeader::MergeFrom(const MapHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rooms_amount()) {
      set_rooms_amount(from.rooms_amount());
    }
    if (from.has_areas_amount()) {
      set_areas_amount(from.areas_amount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapHeader::CopyFrom(const MapHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapHeader::IsInitialized() const {

  return true;
}

void MapHeader::Swap(MapHeader* other) {
  if (other != this) {
    std::swap(rooms_amount_, other->rooms_amount_);
    std::swap(areas_amount_, other->areas_amount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapHeader_descriptor_;
  metadata.reflection = MapHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Area_Alias::kNameFieldNumber;
const int Area_Alias::kDoorFieldNumber;
#endif  // !_MSC_VER

Area_Alias::Area_Alias()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Area_Alias::InitAsDefaultInstance() {
}

Area_Alias::Area_Alias(const Area_Alias& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Area_Alias::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  door_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Area_Alias::~Area_Alias() {
  SharedDtor();
}

void Area_Alias::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (door_ != &::google::protobuf::internal::kEmptyString) {
    delete door_;
  }
  if (this != default_instance_) {
  }
}

void Area_Alias::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Area_Alias::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Area_Alias_descriptor_;
}

const Area_Alias& Area_Alias::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Area_Alias* Area_Alias::default_instance_ = NULL;

Area_Alias* Area_Alias::New() const {
  return new Area_Alias;
}

void Area_Alias::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_door()) {
      if (door_ != &::google::protobuf::internal::kEmptyString) {
        door_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Area_Alias::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_door;
        break;
      }

      // required string door = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_door:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_door()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->door().data(), this->door().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Area_Alias::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required string door = 2;
  if (has_door()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->door().data(), this->door().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->door(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Area_Alias::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required string door = 2;
  if (has_door()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->door().data(), this->door().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->door(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Area_Alias::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string door = 2;
    if (has_door()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->door());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Area_Alias::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Area_Alias* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Area_Alias*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Area_Alias::MergeFrom(const Area_Alias& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_door()) {
      set_door(from.door());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Area_Alias::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Area_Alias::CopyFrom(const Area_Alias& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Area_Alias::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Area_Alias::Swap(Area_Alias* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(door_, other->door_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Area_Alias::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Area_Alias_descriptor_;
  metadata.reflection = Area_Alias_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Area::kNameFieldNumber;
const int Area::kAliasFieldNumber;
const int Area::kScaleFieldNumber;
#endif  // !_MSC_VER

Area::Area()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Area::InitAsDefaultInstance() {
}

Area::Area(const Area& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Area::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  scale_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Area::~Area() {
  SharedDtor();
}

void Area::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Area::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Area::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Area_descriptor_;
}

const Area& Area::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Area* Area::default_instance_ = NULL;

Area* Area::New() const {
  return new Area;
}

void Area::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    scale_ = 1;
  }
  alias_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Area::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        break;
      }

      // repeated .mapdata.Area.Alias alias = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_alias:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_alias()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_alias;
        if (input->ExpectTag(29)) goto parse_scale;
        break;
      }

      // optional float scale = 3 [default = 1];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Area::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // repeated .mapdata.Area.Alias alias = 2;
  for (int i = 0; i < this->alias_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->alias(i), output);
  }

  // optional float scale = 3 [default = 1];
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->scale(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Area::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // repeated .mapdata.Area.Alias alias = 2;
  for (int i = 0; i < this->alias_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->alias(i), target);
  }

  // optional float scale = 3 [default = 1];
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->scale(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Area::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional float scale = 3 [default = 1];
    if (has_scale()) {
      total_size += 1 + 4;
    }

  }
  // repeated .mapdata.Area.Alias alias = 2;
  total_size += 1 * this->alias_size();
  for (int i = 0; i < this->alias_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->alias(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Area::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Area* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Area*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Area::MergeFrom(const Area& from) {
  GOOGLE_CHECK_NE(&from, this);
  alias_.MergeFrom(from.alias_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Area::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Area::CopyFrom(const Area& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Area::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < alias_size(); i++) {
    if (!this->alias(i).IsInitialized()) return false;
  }
  return true;
}

void Area::Swap(Area* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    alias_.Swap(&other->alias_);
    std::swap(scale_, other->scale_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Area::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Area_descriptor_;
  metadata.reflection = Area_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Exit_ExitType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exit_ExitType_descriptor_;
}
bool Exit_ExitType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Exit_ExitType Exit::ET_NORMAL;
const Exit_ExitType Exit::ET_LOOP;
const Exit_ExitType Exit::ET_ONEWAY;
const Exit_ExitType Exit::ET_UNDEFINED;
const Exit_ExitType Exit::ET_DEATH;
const Exit_ExitType Exit::ET_NONE;
const Exit_ExitType Exit::ExitType_MIN;
const Exit_ExitType Exit::ExitType_MAX;
const int Exit::ExitType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Exit_ExitDirection_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exit_ExitDirection_descriptor_;
}
bool Exit_ExitDirection_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Exit_ExitDirection Exit::ED_NORTH;
const Exit_ExitDirection Exit::ED_SOUTH;
const Exit_ExitDirection Exit::ED_EAST;
const Exit_ExitDirection Exit::ED_WEST;
const Exit_ExitDirection Exit::ED_UP;
const Exit_ExitDirection Exit::ED_DOWN;
const Exit_ExitDirection Exit::ED_UNKNOWN;
const Exit_ExitDirection Exit::ExitDirection_MIN;
const Exit_ExitDirection Exit::ExitDirection_MAX;
const int Exit::ExitDirection_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Exit_ExitFlags::kExitFieldNumber;
const int Exit_ExitFlags::kDoorFieldNumber;
const int Exit_ExitFlags::kRoadFieldNumber;
const int Exit_ExitFlags::kClimbFieldNumber;
const int Exit_ExitFlags::kRandomFieldNumber;
const int Exit_ExitFlags::kSpecialFieldNumber;
const int Exit_ExitFlags::kNoMatchFieldNumber;
#endif  // !_MSC_VER

Exit_ExitFlags::Exit_ExitFlags()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Exit_ExitFlags::InitAsDefaultInstance() {
}

Exit_ExitFlags::Exit_ExitFlags(const Exit_ExitFlags& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Exit_ExitFlags::SharedCtor() {
  _cached_size_ = 0;
  exit_ = false;
  door_ = false;
  road_ = false;
  climb_ = false;
  random_ = false;
  special_ = false;
  no_match_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Exit_ExitFlags::~Exit_ExitFlags() {
  SharedDtor();
}

void Exit_ExitFlags::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Exit_ExitFlags::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Exit_ExitFlags::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exit_ExitFlags_descriptor_;
}

const Exit_ExitFlags& Exit_ExitFlags::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Exit_ExitFlags* Exit_ExitFlags::default_instance_ = NULL;

Exit_ExitFlags* Exit_ExitFlags::New() const {
  return new Exit_ExitFlags;
}

void Exit_ExitFlags::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    exit_ = false;
    door_ = false;
    road_ = false;
    climb_ = false;
    random_ = false;
    special_ = false;
    no_match_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Exit_ExitFlags::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool exit = 1 [default = false];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &exit_)));
          set_has_exit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_door;
        break;
      }

      // optional bool door = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_door:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &door_)));
          set_has_door();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_road;
        break;
      }

      // optional bool road = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_road:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &road_)));
          set_has_road();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_climb;
        break;
      }

      // optional bool climb = 4 [default = false];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_climb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &climb_)));
          set_has_climb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_random;
        break;
      }

      // optional bool random = 5 [default = false];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_random:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &random_)));
          set_has_random();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_special;
        break;
      }

      // optional bool special = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_special:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &special_)));
          set_has_special();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_no_match;
        break;
      }

      // optional bool no_match = 7 [default = false];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_no_match:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &no_match_)));
          set_has_no_match();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Exit_ExitFlags::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool exit = 1 [default = false];
  if (has_exit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->exit(), output);
  }

  // optional bool door = 2 [default = false];
  if (has_door()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->door(), output);
  }

  // optional bool road = 3 [default = false];
  if (has_road()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->road(), output);
  }

  // optional bool climb = 4 [default = false];
  if (has_climb()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->climb(), output);
  }

  // optional bool random = 5 [default = false];
  if (has_random()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->random(), output);
  }

  // optional bool special = 6 [default = false];
  if (has_special()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->special(), output);
  }

  // optional bool no_match = 7 [default = false];
  if (has_no_match()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->no_match(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Exit_ExitFlags::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool exit = 1 [default = false];
  if (has_exit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->exit(), target);
  }

  // optional bool door = 2 [default = false];
  if (has_door()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->door(), target);
  }

  // optional bool road = 3 [default = false];
  if (has_road()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->road(), target);
  }

  // optional bool climb = 4 [default = false];
  if (has_climb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->climb(), target);
  }

  // optional bool random = 5 [default = false];
  if (has_random()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->random(), target);
  }

  // optional bool special = 6 [default = false];
  if (has_special()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->special(), target);
  }

  // optional bool no_match = 7 [default = false];
  if (has_no_match()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->no_match(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Exit_ExitFlags::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool exit = 1 [default = false];
    if (has_exit()) {
      total_size += 1 + 1;
    }

    // optional bool door = 2 [default = false];
    if (has_door()) {
      total_size += 1 + 1;
    }

    // optional bool road = 3 [default = false];
    if (has_road()) {
      total_size += 1 + 1;
    }

    // optional bool climb = 4 [default = false];
    if (has_climb()) {
      total_size += 1 + 1;
    }

    // optional bool random = 5 [default = false];
    if (has_random()) {
      total_size += 1 + 1;
    }

    // optional bool special = 6 [default = false];
    if (has_special()) {
      total_size += 1 + 1;
    }

    // optional bool no_match = 7 [default = false];
    if (has_no_match()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Exit_ExitFlags::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Exit_ExitFlags* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Exit_ExitFlags*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Exit_ExitFlags::MergeFrom(const Exit_ExitFlags& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exit()) {
      set_exit(from.exit());
    }
    if (from.has_door()) {
      set_door(from.door());
    }
    if (from.has_road()) {
      set_road(from.road());
    }
    if (from.has_climb()) {
      set_climb(from.climb());
    }
    if (from.has_random()) {
      set_random(from.random());
    }
    if (from.has_special()) {
      set_special(from.special());
    }
    if (from.has_no_match()) {
      set_no_match(from.no_match());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Exit_ExitFlags::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Exit_ExitFlags::CopyFrom(const Exit_ExitFlags& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Exit_ExitFlags::IsInitialized() const {

  return true;
}

void Exit_ExitFlags::Swap(Exit_ExitFlags* other) {
  if (other != this) {
    std::swap(exit_, other->exit_);
    std::swap(door_, other->door_);
    std::swap(road_, other->road_);
    std::swap(climb_, other->climb_);
    std::swap(random_, other->random_);
    std::swap(special_, other->special_);
    std::swap(no_match_, other->no_match_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Exit_ExitFlags::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Exit_ExitFlags_descriptor_;
  metadata.reflection = Exit_ExitFlags_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Exit_DoorFlags::kHiddenFieldNumber;
const int Exit_DoorFlags::kNeedkeyFieldNumber;
const int Exit_DoorFlags::kNoblockFieldNumber;
const int Exit_DoorFlags::kNobreakFieldNumber;
const int Exit_DoorFlags::kNopickFieldNumber;
const int Exit_DoorFlags::kDelayedFieldNumber;
#endif  // !_MSC_VER

Exit_DoorFlags::Exit_DoorFlags()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Exit_DoorFlags::InitAsDefaultInstance() {
}

Exit_DoorFlags::Exit_DoorFlags(const Exit_DoorFlags& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Exit_DoorFlags::SharedCtor() {
  _cached_size_ = 0;
  hidden_ = false;
  needkey_ = false;
  noblock_ = false;
  nobreak_ = false;
  nopick_ = false;
  delayed_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Exit_DoorFlags::~Exit_DoorFlags() {
  SharedDtor();
}

void Exit_DoorFlags::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Exit_DoorFlags::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Exit_DoorFlags::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exit_DoorFlags_descriptor_;
}

const Exit_DoorFlags& Exit_DoorFlags::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Exit_DoorFlags* Exit_DoorFlags::default_instance_ = NULL;

Exit_DoorFlags* Exit_DoorFlags::New() const {
  return new Exit_DoorFlags;
}

void Exit_DoorFlags::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    hidden_ = false;
    needkey_ = false;
    noblock_ = false;
    nobreak_ = false;
    nopick_ = false;
    delayed_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Exit_DoorFlags::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool hidden = 1 [default = false];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hidden_)));
          set_has_hidden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_needkey;
        break;
      }

      // optional bool needkey = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_needkey:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &needkey_)));
          set_has_needkey();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_noblock;
        break;
      }

      // optional bool noblock = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_noblock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &noblock_)));
          set_has_noblock();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_nobreak;
        break;
      }

      // optional bool nobreak = 4 [default = false];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nobreak:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &nobreak_)));
          set_has_nobreak();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_nopick;
        break;
      }

      // optional bool nopick = 5 [default = false];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nopick:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &nopick_)));
          set_has_nopick();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_delayed;
        break;
      }

      // optional bool delayed = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_delayed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &delayed_)));
          set_has_delayed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Exit_DoorFlags::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool hidden = 1 [default = false];
  if (has_hidden()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->hidden(), output);
  }

  // optional bool needkey = 2 [default = false];
  if (has_needkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->needkey(), output);
  }

  // optional bool noblock = 3 [default = false];
  if (has_noblock()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->noblock(), output);
  }

  // optional bool nobreak = 4 [default = false];
  if (has_nobreak()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->nobreak(), output);
  }

  // optional bool nopick = 5 [default = false];
  if (has_nopick()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->nopick(), output);
  }

  // optional bool delayed = 6 [default = false];
  if (has_delayed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->delayed(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Exit_DoorFlags::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool hidden = 1 [default = false];
  if (has_hidden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->hidden(), target);
  }

  // optional bool needkey = 2 [default = false];
  if (has_needkey()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->needkey(), target);
  }

  // optional bool noblock = 3 [default = false];
  if (has_noblock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->noblock(), target);
  }

  // optional bool nobreak = 4 [default = false];
  if (has_nobreak()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->nobreak(), target);
  }

  // optional bool nopick = 5 [default = false];
  if (has_nopick()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->nopick(), target);
  }

  // optional bool delayed = 6 [default = false];
  if (has_delayed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->delayed(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Exit_DoorFlags::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool hidden = 1 [default = false];
    if (has_hidden()) {
      total_size += 1 + 1;
    }

    // optional bool needkey = 2 [default = false];
    if (has_needkey()) {
      total_size += 1 + 1;
    }

    // optional bool noblock = 3 [default = false];
    if (has_noblock()) {
      total_size += 1 + 1;
    }

    // optional bool nobreak = 4 [default = false];
    if (has_nobreak()) {
      total_size += 1 + 1;
    }

    // optional bool nopick = 5 [default = false];
    if (has_nopick()) {
      total_size += 1 + 1;
    }

    // optional bool delayed = 6 [default = false];
    if (has_delayed()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Exit_DoorFlags::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Exit_DoorFlags* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Exit_DoorFlags*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Exit_DoorFlags::MergeFrom(const Exit_DoorFlags& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hidden()) {
      set_hidden(from.hidden());
    }
    if (from.has_needkey()) {
      set_needkey(from.needkey());
    }
    if (from.has_noblock()) {
      set_noblock(from.noblock());
    }
    if (from.has_nobreak()) {
      set_nobreak(from.nobreak());
    }
    if (from.has_nopick()) {
      set_nopick(from.nopick());
    }
    if (from.has_delayed()) {
      set_delayed(from.delayed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Exit_DoorFlags::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Exit_DoorFlags::CopyFrom(const Exit_DoorFlags& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Exit_DoorFlags::IsInitialized() const {

  return true;
}

void Exit_DoorFlags::Swap(Exit_DoorFlags* other) {
  if (other != this) {
    std::swap(hidden_, other->hidden_);
    std::swap(needkey_, other->needkey_);
    std::swap(noblock_, other->noblock_);
    std::swap(nobreak_, other->nobreak_);
    std::swap(nopick_, other->nopick_);
    std::swap(delayed_, other->delayed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Exit_DoorFlags::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Exit_DoorFlags_descriptor_;
  metadata.reflection = Exit_DoorFlags_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Exit::kDirFieldNumber;
const int Exit::kLeadsToIdFieldNumber;
const int Exit::kTypeFieldNumber;
const int Exit::kDoorFieldNumber;
const int Exit::kExitFlagsFieldNumber;
const int Exit::kDoorFlagsFieldNumber;
#endif  // !_MSC_VER

Exit::Exit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Exit::InitAsDefaultInstance() {
  exit_flags_ = const_cast< ::mapdata::Exit_ExitFlags*>(&::mapdata::Exit_ExitFlags::default_instance());
  door_flags_ = const_cast< ::mapdata::Exit_DoorFlags*>(&::mapdata::Exit_DoorFlags::default_instance());
}

Exit::Exit(const Exit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Exit::SharedCtor() {
  _cached_size_ = 0;
  dir_ = 6;
  leads_to_id_ = 0;
  type_ = 5;
  door_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  exit_flags_ = NULL;
  door_flags_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Exit::~Exit() {
  SharedDtor();
}

void Exit::SharedDtor() {
  if (door_ != &::google::protobuf::internal::kEmptyString) {
    delete door_;
  }
  if (this != default_instance_) {
    delete exit_flags_;
    delete door_flags_;
  }
}

void Exit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Exit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Exit_descriptor_;
}

const Exit& Exit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Exit* Exit::default_instance_ = NULL;

Exit* Exit::New() const {
  return new Exit;
}

void Exit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    dir_ = 6;
    leads_to_id_ = 0;
    type_ = 5;
    if (has_door()) {
      if (door_ != &::google::protobuf::internal::kEmptyString) {
        door_->clear();
      }
    }
    if (has_exit_flags()) {
      if (exit_flags_ != NULL) exit_flags_->::mapdata::Exit_ExitFlags::Clear();
    }
    if (has_door_flags()) {
      if (door_flags_ != NULL) door_flags_->::mapdata::Exit_DoorFlags::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Exit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mapdata.Exit.ExitDirection dir = 1 [default = ED_UNKNOWN];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapdata::Exit_ExitDirection_IsValid(value)) {
            set_dir(static_cast< ::mapdata::Exit_ExitDirection >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_leads_to_id;
        break;
      }

      // optional int32 leads_to_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_leads_to_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &leads_to_id_)));
          set_has_leads_to_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .mapdata.Exit.ExitType type = 3 [default = ET_NONE];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapdata::Exit_ExitType_IsValid(value)) {
            set_type(static_cast< ::mapdata::Exit_ExitType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_door;
        break;
      }

      // optional string door = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_door:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_door()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->door().data(), this->door().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_exit_flags;
        break;
      }

      // optional .mapdata.Exit.ExitFlags exit_flags = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_flags:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exit_flags()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_door_flags;
        break;
      }

      // optional .mapdata.Exit.DoorFlags door_flags = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_door_flags:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_door_flags()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Exit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .mapdata.Exit.ExitDirection dir = 1 [default = ED_UNKNOWN];
  if (has_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->dir(), output);
  }

  // optional int32 leads_to_id = 2;
  if (has_leads_to_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->leads_to_id(), output);
  }

  // optional .mapdata.Exit.ExitType type = 3 [default = ET_NONE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional string door = 4;
  if (has_door()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->door().data(), this->door().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->door(), output);
  }

  // optional .mapdata.Exit.ExitFlags exit_flags = 5;
  if (has_exit_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->exit_flags(), output);
  }

  // optional .mapdata.Exit.DoorFlags door_flags = 6;
  if (has_door_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->door_flags(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Exit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .mapdata.Exit.ExitDirection dir = 1 [default = ED_UNKNOWN];
  if (has_dir()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->dir(), target);
  }

  // optional int32 leads_to_id = 2;
  if (has_leads_to_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->leads_to_id(), target);
  }

  // optional .mapdata.Exit.ExitType type = 3 [default = ET_NONE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional string door = 4;
  if (has_door()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->door().data(), this->door().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->door(), target);
  }

  // optional .mapdata.Exit.ExitFlags exit_flags = 5;
  if (has_exit_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->exit_flags(), target);
  }

  // optional .mapdata.Exit.DoorFlags door_flags = 6;
  if (has_door_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->door_flags(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Exit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .mapdata.Exit.ExitDirection dir = 1 [default = ED_UNKNOWN];
    if (has_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->dir());
    }

    // optional int32 leads_to_id = 2;
    if (has_leads_to_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->leads_to_id());
    }

    // optional .mapdata.Exit.ExitType type = 3 [default = ET_NONE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string door = 4;
    if (has_door()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->door());
    }

    // optional .mapdata.Exit.ExitFlags exit_flags = 5;
    if (has_exit_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exit_flags());
    }

    // optional .mapdata.Exit.DoorFlags door_flags = 6;
    if (has_door_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->door_flags());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Exit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Exit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Exit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Exit::MergeFrom(const Exit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dir()) {
      set_dir(from.dir());
    }
    if (from.has_leads_to_id()) {
      set_leads_to_id(from.leads_to_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_door()) {
      set_door(from.door());
    }
    if (from.has_exit_flags()) {
      mutable_exit_flags()->::mapdata::Exit_ExitFlags::MergeFrom(from.exit_flags());
    }
    if (from.has_door_flags()) {
      mutable_door_flags()->::mapdata::Exit_DoorFlags::MergeFrom(from.door_flags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Exit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Exit::CopyFrom(const Exit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Exit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Exit::Swap(Exit* other) {
  if (other != this) {
    std::swap(dir_, other->dir_);
    std::swap(leads_to_id_, other->leads_to_id_);
    std::swap(type_, other->type_);
    std::swap(door_, other->door_);
    std::swap(exit_flags_, other->exit_flags_);
    std::swap(door_flags_, other->door_flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Exit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Exit_descriptor_;
  metadata.reflection = Exit_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Room_RoomTerrainType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_RoomTerrainType_descriptor_;
}
bool Room_RoomTerrainType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Room_RoomTerrainType Room::RTT_UNDEFINED;
const Room_RoomTerrainType Room::RTT_INDOORS;
const Room_RoomTerrainType Room::RTT_CITY;
const Room_RoomTerrainType Room::RTT_FIELD;
const Room_RoomTerrainType Room::RTT_FOREST;
const Room_RoomTerrainType Room::RTT_HILLS;
const Room_RoomTerrainType Room::RTT_MOUNTAINS;
const Room_RoomTerrainType Room::RTT_SHALLOW;
const Room_RoomTerrainType Room::RTT_WATER;
const Room_RoomTerrainType Room::RTT_RAPIDS;
const Room_RoomTerrainType Room::RTT_UNDERWATER;
const Room_RoomTerrainType Room::RTT_ROAD;
const Room_RoomTerrainType Room::RTT_BRUSH;
const Room_RoomTerrainType Room::RTT_TUNNEL;
const Room_RoomTerrainType Room::RTT_CAVERN;
const Room_RoomTerrainType Room::RTT_DEATHTRAP;
const Room_RoomTerrainType Room::RTT_RANDOM;
const Room_RoomTerrainType Room::RoomTerrainType_MIN;
const Room_RoomTerrainType Room::RoomTerrainType_MAX;
const int Room::RoomTerrainType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Room_RoomPortableType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_RoomPortableType_descriptor_;
}
bool Room_RoomPortableType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Room_RoomPortableType Room::RPT_UNDEFINED;
const Room_RoomPortableType Room::RPT_PORTABLE;
const Room_RoomPortableType Room::RPT_NOTPORTABLE;
const Room_RoomPortableType Room::RoomPortableType_MIN;
const Room_RoomPortableType Room::RoomPortableType_MAX;
const int Room::RoomPortableType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Room_RoomLightType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_RoomLightType_descriptor_;
}
bool Room_RoomLightType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Room_RoomLightType Room::RLT_UNDEFINED;
const Room_RoomLightType Room::RLT_DARK;
const Room_RoomLightType Room::RLT_LIT;
const Room_RoomLightType Room::RoomLightType_MIN;
const Room_RoomLightType Room::RoomLightType_MAX;
const int Room::RoomLightType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Room_RoomAlignType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_RoomAlignType_descriptor_;
}
bool Room_RoomAlignType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Room_RoomAlignType Room::RAT_UNDEFINED;
const Room_RoomAlignType Room::RAT_GOOD;
const Room_RoomAlignType Room::RAT_NEUTRAL;
const Room_RoomAlignType Room::RAT_EVIL;
const Room_RoomAlignType Room::RoomAlignType_MIN;
const Room_RoomAlignType Room::RoomAlignType_MAX;
const int Room::RoomAlignType_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Room_RoomRidableType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_RoomRidableType_descriptor_;
}
bool Room_RoomRidableType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Room_RoomRidableType Room::RRT_UNDEFINED;
const Room_RoomRidableType Room::RRT_RIDABLE;
const Room_RoomRidableType Room::RRT_NOTRIDABLE;
const Room_RoomRidableType Room::RoomRidableType_MIN;
const Room_RoomRidableType Room::RoomRidableType_MAX;
const int Room::RoomRidableType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Room_MobFlags::kRentFieldNumber;
const int Room_MobFlags::kShopFieldNumber;
const int Room_MobFlags::kWeaponshopFieldNumber;
const int Room_MobFlags::kArmourshopFieldNumber;
const int Room_MobFlags::kFoodshopFieldNumber;
const int Room_MobFlags::kPetshopFieldNumber;
const int Room_MobFlags::kGuildFieldNumber;
const int Room_MobFlags::kScoutguildFieldNumber;
const int Room_MobFlags::kMageguildFieldNumber;
const int Room_MobFlags::kClericguildFieldNumber;
const int Room_MobFlags::kWarriorguildFieldNumber;
const int Room_MobFlags::kRangerguildFieldNumber;
const int Room_MobFlags::kSmobFieldNumber;
const int Room_MobFlags::kQuestFieldNumber;
const int Room_MobFlags::kAnyFieldNumber;
#endif  // !_MSC_VER

Room_MobFlags::Room_MobFlags()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Room_MobFlags::InitAsDefaultInstance() {
}

Room_MobFlags::Room_MobFlags(const Room_MobFlags& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Room_MobFlags::SharedCtor() {
  _cached_size_ = 0;
  rent_ = false;
  shop_ = false;
  weaponshop_ = false;
  armourshop_ = false;
  foodshop_ = false;
  petshop_ = false;
  guild_ = false;
  scoutguild_ = false;
  mageguild_ = false;
  clericguild_ = false;
  warriorguild_ = false;
  rangerguild_ = false;
  smob_ = false;
  quest_ = false;
  any_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Room_MobFlags::~Room_MobFlags() {
  SharedDtor();
}

void Room_MobFlags::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Room_MobFlags::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Room_MobFlags::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_MobFlags_descriptor_;
}

const Room_MobFlags& Room_MobFlags::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Room_MobFlags* Room_MobFlags::default_instance_ = NULL;

Room_MobFlags* Room_MobFlags::New() const {
  return new Room_MobFlags;
}

void Room_MobFlags::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rent_ = false;
    shop_ = false;
    weaponshop_ = false;
    armourshop_ = false;
    foodshop_ = false;
    petshop_ = false;
    guild_ = false;
    scoutguild_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    mageguild_ = false;
    clericguild_ = false;
    warriorguild_ = false;
    rangerguild_ = false;
    smob_ = false;
    quest_ = false;
    any_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Room_MobFlags::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool rent = 1 [default = false];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rent_)));
          set_has_rent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_shop;
        break;
      }

      // optional bool shop = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shop_)));
          set_has_shop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_weaponshop;
        break;
      }

      // optional bool weaponshop = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weaponshop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &weaponshop_)));
          set_has_weaponshop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_armourshop;
        break;
      }

      // optional bool armourshop = 4 [default = false];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_armourshop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &armourshop_)));
          set_has_armourshop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_foodshop;
        break;
      }

      // optional bool foodshop = 5 [default = false];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_foodshop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &foodshop_)));
          set_has_foodshop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_petshop;
        break;
      }

      // optional bool petshop = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_petshop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &petshop_)));
          set_has_petshop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_guild;
        break;
      }

      // optional bool guild = 7 [default = false];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guild:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &guild_)));
          set_has_guild();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_scoutguild;
        break;
      }

      // optional bool scoutguild = 8 [default = false];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_scoutguild:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &scoutguild_)));
          set_has_scoutguild();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_mageguild;
        break;
      }

      // optional bool mageguild = 9 [default = false];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mageguild:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mageguild_)));
          set_has_mageguild();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_clericguild;
        break;
      }

      // optional bool clericguild = 10 [default = false];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clericguild:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &clericguild_)));
          set_has_clericguild();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_warriorguild;
        break;
      }

      // optional bool warriorguild = 11 [default = false];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_warriorguild:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &warriorguild_)));
          set_has_warriorguild();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_rangerguild;
        break;
      }

      // optional bool rangerguild = 12 [default = false];
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rangerguild:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rangerguild_)));
          set_has_rangerguild();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_smob;
        break;
      }

      // optional bool smob = 13 [default = false];
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_smob:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &smob_)));
          set_has_smob();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_quest;
        break;
      }

      // optional bool quest = 14 [default = false];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_quest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &quest_)));
          set_has_quest();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_any;
        break;
      }

      // optional bool any = 15 [default = false];
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_any:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &any_)));
          set_has_any();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Room_MobFlags::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool rent = 1 [default = false];
  if (has_rent()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->rent(), output);
  }

  // optional bool shop = 2 [default = false];
  if (has_shop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->shop(), output);
  }

  // optional bool weaponshop = 3 [default = false];
  if (has_weaponshop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->weaponshop(), output);
  }

  // optional bool armourshop = 4 [default = false];
  if (has_armourshop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->armourshop(), output);
  }

  // optional bool foodshop = 5 [default = false];
  if (has_foodshop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->foodshop(), output);
  }

  // optional bool petshop = 6 [default = false];
  if (has_petshop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->petshop(), output);
  }

  // optional bool guild = 7 [default = false];
  if (has_guild()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->guild(), output);
  }

  // optional bool scoutguild = 8 [default = false];
  if (has_scoutguild()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->scoutguild(), output);
  }

  // optional bool mageguild = 9 [default = false];
  if (has_mageguild()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->mageguild(), output);
  }

  // optional bool clericguild = 10 [default = false];
  if (has_clericguild()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->clericguild(), output);
  }

  // optional bool warriorguild = 11 [default = false];
  if (has_warriorguild()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->warriorguild(), output);
  }

  // optional bool rangerguild = 12 [default = false];
  if (has_rangerguild()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->rangerguild(), output);
  }

  // optional bool smob = 13 [default = false];
  if (has_smob()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->smob(), output);
  }

  // optional bool quest = 14 [default = false];
  if (has_quest()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->quest(), output);
  }

  // optional bool any = 15 [default = false];
  if (has_any()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->any(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Room_MobFlags::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool rent = 1 [default = false];
  if (has_rent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->rent(), target);
  }

  // optional bool shop = 2 [default = false];
  if (has_shop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->shop(), target);
  }

  // optional bool weaponshop = 3 [default = false];
  if (has_weaponshop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->weaponshop(), target);
  }

  // optional bool armourshop = 4 [default = false];
  if (has_armourshop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->armourshop(), target);
  }

  // optional bool foodshop = 5 [default = false];
  if (has_foodshop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->foodshop(), target);
  }

  // optional bool petshop = 6 [default = false];
  if (has_petshop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->petshop(), target);
  }

  // optional bool guild = 7 [default = false];
  if (has_guild()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->guild(), target);
  }

  // optional bool scoutguild = 8 [default = false];
  if (has_scoutguild()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->scoutguild(), target);
  }

  // optional bool mageguild = 9 [default = false];
  if (has_mageguild()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->mageguild(), target);
  }

  // optional bool clericguild = 10 [default = false];
  if (has_clericguild()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->clericguild(), target);
  }

  // optional bool warriorguild = 11 [default = false];
  if (has_warriorguild()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->warriorguild(), target);
  }

  // optional bool rangerguild = 12 [default = false];
  if (has_rangerguild()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->rangerguild(), target);
  }

  // optional bool smob = 13 [default = false];
  if (has_smob()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->smob(), target);
  }

  // optional bool quest = 14 [default = false];
  if (has_quest()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->quest(), target);
  }

  // optional bool any = 15 [default = false];
  if (has_any()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->any(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Room_MobFlags::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool rent = 1 [default = false];
    if (has_rent()) {
      total_size += 1 + 1;
    }

    // optional bool shop = 2 [default = false];
    if (has_shop()) {
      total_size += 1 + 1;
    }

    // optional bool weaponshop = 3 [default = false];
    if (has_weaponshop()) {
      total_size += 1 + 1;
    }

    // optional bool armourshop = 4 [default = false];
    if (has_armourshop()) {
      total_size += 1 + 1;
    }

    // optional bool foodshop = 5 [default = false];
    if (has_foodshop()) {
      total_size += 1 + 1;
    }

    // optional bool petshop = 6 [default = false];
    if (has_petshop()) {
      total_size += 1 + 1;
    }

    // optional bool guild = 7 [default = false];
    if (has_guild()) {
      total_size += 1 + 1;
    }

    // optional bool scoutguild = 8 [default = false];
    if (has_scoutguild()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool mageguild = 9 [default = false];
    if (has_mageguild()) {
      total_size += 1 + 1;
    }

    // optional bool clericguild = 10 [default = false];
    if (has_clericguild()) {
      total_size += 1 + 1;
    }

    // optional bool warriorguild = 11 [default = false];
    if (has_warriorguild()) {
      total_size += 1 + 1;
    }

    // optional bool rangerguild = 12 [default = false];
    if (has_rangerguild()) {
      total_size += 1 + 1;
    }

    // optional bool smob = 13 [default = false];
    if (has_smob()) {
      total_size += 1 + 1;
    }

    // optional bool quest = 14 [default = false];
    if (has_quest()) {
      total_size += 1 + 1;
    }

    // optional bool any = 15 [default = false];
    if (has_any()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Room_MobFlags::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Room_MobFlags* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Room_MobFlags*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Room_MobFlags::MergeFrom(const Room_MobFlags& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rent()) {
      set_rent(from.rent());
    }
    if (from.has_shop()) {
      set_shop(from.shop());
    }
    if (from.has_weaponshop()) {
      set_weaponshop(from.weaponshop());
    }
    if (from.has_armourshop()) {
      set_armourshop(from.armourshop());
    }
    if (from.has_foodshop()) {
      set_foodshop(from.foodshop());
    }
    if (from.has_petshop()) {
      set_petshop(from.petshop());
    }
    if (from.has_guild()) {
      set_guild(from.guild());
    }
    if (from.has_scoutguild()) {
      set_scoutguild(from.scoutguild());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_mageguild()) {
      set_mageguild(from.mageguild());
    }
    if (from.has_clericguild()) {
      set_clericguild(from.clericguild());
    }
    if (from.has_warriorguild()) {
      set_warriorguild(from.warriorguild());
    }
    if (from.has_rangerguild()) {
      set_rangerguild(from.rangerguild());
    }
    if (from.has_smob()) {
      set_smob(from.smob());
    }
    if (from.has_quest()) {
      set_quest(from.quest());
    }
    if (from.has_any()) {
      set_any(from.any());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Room_MobFlags::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Room_MobFlags::CopyFrom(const Room_MobFlags& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_MobFlags::IsInitialized() const {

  return true;
}

void Room_MobFlags::Swap(Room_MobFlags* other) {
  if (other != this) {
    std::swap(rent_, other->rent_);
    std::swap(shop_, other->shop_);
    std::swap(weaponshop_, other->weaponshop_);
    std::swap(armourshop_, other->armourshop_);
    std::swap(foodshop_, other->foodshop_);
    std::swap(petshop_, other->petshop_);
    std::swap(guild_, other->guild_);
    std::swap(scoutguild_, other->scoutguild_);
    std::swap(mageguild_, other->mageguild_);
    std::swap(clericguild_, other->clericguild_);
    std::swap(warriorguild_, other->warriorguild_);
    std::swap(rangerguild_, other->rangerguild_);
    std::swap(smob_, other->smob_);
    std::swap(quest_, other->quest_);
    std::swap(any_, other->any_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Room_MobFlags::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Room_MobFlags_descriptor_;
  metadata.reflection = Room_MobFlags_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Room_LoadFlags::kTreasureFieldNumber;
const int Room_LoadFlags::kArmourFieldNumber;
const int Room_LoadFlags::kWeaponFieldNumber;
const int Room_LoadFlags::kWaterFieldNumber;
const int Room_LoadFlags::kFoodFieldNumber;
const int Room_LoadFlags::kHerbFieldNumber;
const int Room_LoadFlags::kKeyFieldNumber;
const int Room_LoadFlags::kMuleFieldNumber;
const int Room_LoadFlags::kHorseFieldNumber;
const int Room_LoadFlags::kPackhorseFieldNumber;
const int Room_LoadFlags::kTrainedhorseFieldNumber;
const int Room_LoadFlags::kRohirrimFieldNumber;
const int Room_LoadFlags::kWargFieldNumber;
const int Room_LoadFlags::kBoatFieldNumber;
const int Room_LoadFlags::kAttentionFieldNumber;
const int Room_LoadFlags::kTowerFieldNumber;
#endif  // !_MSC_VER

Room_LoadFlags::Room_LoadFlags()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Room_LoadFlags::InitAsDefaultInstance() {
}

Room_LoadFlags::Room_LoadFlags(const Room_LoadFlags& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Room_LoadFlags::SharedCtor() {
  _cached_size_ = 0;
  treasure_ = false;
  armour_ = false;
  weapon_ = false;
  water_ = false;
  food_ = false;
  herb_ = false;
  key_ = false;
  mule_ = false;
  horse_ = false;
  packhorse_ = false;
  trainedhorse_ = false;
  rohirrim_ = false;
  warg_ = false;
  boat_ = false;
  attention_ = false;
  tower_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Room_LoadFlags::~Room_LoadFlags() {
  SharedDtor();
}

void Room_LoadFlags::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Room_LoadFlags::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Room_LoadFlags::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_LoadFlags_descriptor_;
}

const Room_LoadFlags& Room_LoadFlags::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Room_LoadFlags* Room_LoadFlags::default_instance_ = NULL;

Room_LoadFlags* Room_LoadFlags::New() const {
  return new Room_LoadFlags;
}

void Room_LoadFlags::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    treasure_ = false;
    armour_ = false;
    weapon_ = false;
    water_ = false;
    food_ = false;
    herb_ = false;
    key_ = false;
    mule_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    horse_ = false;
    packhorse_ = false;
    trainedhorse_ = false;
    rohirrim_ = false;
    warg_ = false;
    boat_ = false;
    attention_ = false;
    tower_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Room_LoadFlags::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool treasure = 1 [default = false];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &treasure_)));
          set_has_treasure();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_armour;
        break;
      }

      // optional bool armour = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_armour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &armour_)));
          set_has_armour();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_weapon;
        break;
      }

      // optional bool weapon = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_weapon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &weapon_)));
          set_has_weapon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_water;
        break;
      }

      // optional bool water = 4 [default = false];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_water:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &water_)));
          set_has_water();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_food;
        break;
      }

      // optional bool food = 5 [default = false];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_food:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &food_)));
          set_has_food();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_herb;
        break;
      }

      // optional bool herb = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_herb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &herb_)));
          set_has_herb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_key;
        break;
      }

      // optional bool key = 7 [default = false];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &key_)));
          set_has_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_mule;
        break;
      }

      // optional bool mule = 8 [default = false];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mule:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mule_)));
          set_has_mule();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_horse;
        break;
      }

      // optional bool horse = 9 [default = false];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_horse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &horse_)));
          set_has_horse();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_packhorse;
        break;
      }

      // optional bool packhorse = 10 [default = false];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_packhorse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &packhorse_)));
          set_has_packhorse();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_trainedhorse;
        break;
      }

      // optional bool trainedhorse = 11 [default = false];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trainedhorse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &trainedhorse_)));
          set_has_trainedhorse();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_rohirrim;
        break;
      }

      // optional bool rohirrim = 12 [default = false];
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rohirrim:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rohirrim_)));
          set_has_rohirrim();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_warg;
        break;
      }

      // optional bool warg = 13 [default = false];
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_warg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &warg_)));
          set_has_warg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_boat;
        break;
      }

      // optional bool boat = 14 [default = false];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_boat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &boat_)));
          set_has_boat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_attention;
        break;
      }

      // optional bool attention = 15 [default = false];
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attention:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &attention_)));
          set_has_attention();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_tower;
        break;
      }

      // optional bool tower = 16 [default = false];
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tower:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &tower_)));
          set_has_tower();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Room_LoadFlags::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool treasure = 1 [default = false];
  if (has_treasure()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->treasure(), output);
  }

  // optional bool armour = 2 [default = false];
  if (has_armour()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->armour(), output);
  }

  // optional bool weapon = 3 [default = false];
  if (has_weapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->weapon(), output);
  }

  // optional bool water = 4 [default = false];
  if (has_water()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->water(), output);
  }

  // optional bool food = 5 [default = false];
  if (has_food()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->food(), output);
  }

  // optional bool herb = 6 [default = false];
  if (has_herb()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->herb(), output);
  }

  // optional bool key = 7 [default = false];
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->key(), output);
  }

  // optional bool mule = 8 [default = false];
  if (has_mule()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->mule(), output);
  }

  // optional bool horse = 9 [default = false];
  if (has_horse()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->horse(), output);
  }

  // optional bool packhorse = 10 [default = false];
  if (has_packhorse()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->packhorse(), output);
  }

  // optional bool trainedhorse = 11 [default = false];
  if (has_trainedhorse()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->trainedhorse(), output);
  }

  // optional bool rohirrim = 12 [default = false];
  if (has_rohirrim()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->rohirrim(), output);
  }

  // optional bool warg = 13 [default = false];
  if (has_warg()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->warg(), output);
  }

  // optional bool boat = 14 [default = false];
  if (has_boat()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->boat(), output);
  }

  // optional bool attention = 15 [default = false];
  if (has_attention()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->attention(), output);
  }

  // optional bool tower = 16 [default = false];
  if (has_tower()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->tower(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Room_LoadFlags::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool treasure = 1 [default = false];
  if (has_treasure()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->treasure(), target);
  }

  // optional bool armour = 2 [default = false];
  if (has_armour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->armour(), target);
  }

  // optional bool weapon = 3 [default = false];
  if (has_weapon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->weapon(), target);
  }

  // optional bool water = 4 [default = false];
  if (has_water()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->water(), target);
  }

  // optional bool food = 5 [default = false];
  if (has_food()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->food(), target);
  }

  // optional bool herb = 6 [default = false];
  if (has_herb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->herb(), target);
  }

  // optional bool key = 7 [default = false];
  if (has_key()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->key(), target);
  }

  // optional bool mule = 8 [default = false];
  if (has_mule()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->mule(), target);
  }

  // optional bool horse = 9 [default = false];
  if (has_horse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->horse(), target);
  }

  // optional bool packhorse = 10 [default = false];
  if (has_packhorse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->packhorse(), target);
  }

  // optional bool trainedhorse = 11 [default = false];
  if (has_trainedhorse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(11, this->trainedhorse(), target);
  }

  // optional bool rohirrim = 12 [default = false];
  if (has_rohirrim()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->rohirrim(), target);
  }

  // optional bool warg = 13 [default = false];
  if (has_warg()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->warg(), target);
  }

  // optional bool boat = 14 [default = false];
  if (has_boat()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->boat(), target);
  }

  // optional bool attention = 15 [default = false];
  if (has_attention()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->attention(), target);
  }

  // optional bool tower = 16 [default = false];
  if (has_tower()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->tower(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Room_LoadFlags::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool treasure = 1 [default = false];
    if (has_treasure()) {
      total_size += 1 + 1;
    }

    // optional bool armour = 2 [default = false];
    if (has_armour()) {
      total_size += 1 + 1;
    }

    // optional bool weapon = 3 [default = false];
    if (has_weapon()) {
      total_size += 1 + 1;
    }

    // optional bool water = 4 [default = false];
    if (has_water()) {
      total_size += 1 + 1;
    }

    // optional bool food = 5 [default = false];
    if (has_food()) {
      total_size += 1 + 1;
    }

    // optional bool herb = 6 [default = false];
    if (has_herb()) {
      total_size += 1 + 1;
    }

    // optional bool key = 7 [default = false];
    if (has_key()) {
      total_size += 1 + 1;
    }

    // optional bool mule = 8 [default = false];
    if (has_mule()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool horse = 9 [default = false];
    if (has_horse()) {
      total_size += 1 + 1;
    }

    // optional bool packhorse = 10 [default = false];
    if (has_packhorse()) {
      total_size += 1 + 1;
    }

    // optional bool trainedhorse = 11 [default = false];
    if (has_trainedhorse()) {
      total_size += 1 + 1;
    }

    // optional bool rohirrim = 12 [default = false];
    if (has_rohirrim()) {
      total_size += 1 + 1;
    }

    // optional bool warg = 13 [default = false];
    if (has_warg()) {
      total_size += 1 + 1;
    }

    // optional bool boat = 14 [default = false];
    if (has_boat()) {
      total_size += 1 + 1;
    }

    // optional bool attention = 15 [default = false];
    if (has_attention()) {
      total_size += 1 + 1;
    }

    // optional bool tower = 16 [default = false];
    if (has_tower()) {
      total_size += 2 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Room_LoadFlags::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Room_LoadFlags* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Room_LoadFlags*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Room_LoadFlags::MergeFrom(const Room_LoadFlags& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_treasure()) {
      set_treasure(from.treasure());
    }
    if (from.has_armour()) {
      set_armour(from.armour());
    }
    if (from.has_weapon()) {
      set_weapon(from.weapon());
    }
    if (from.has_water()) {
      set_water(from.water());
    }
    if (from.has_food()) {
      set_food(from.food());
    }
    if (from.has_herb()) {
      set_herb(from.herb());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_mule()) {
      set_mule(from.mule());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_horse()) {
      set_horse(from.horse());
    }
    if (from.has_packhorse()) {
      set_packhorse(from.packhorse());
    }
    if (from.has_trainedhorse()) {
      set_trainedhorse(from.trainedhorse());
    }
    if (from.has_rohirrim()) {
      set_rohirrim(from.rohirrim());
    }
    if (from.has_warg()) {
      set_warg(from.warg());
    }
    if (from.has_boat()) {
      set_boat(from.boat());
    }
    if (from.has_attention()) {
      set_attention(from.attention());
    }
    if (from.has_tower()) {
      set_tower(from.tower());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Room_LoadFlags::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Room_LoadFlags::CopyFrom(const Room_LoadFlags& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_LoadFlags::IsInitialized() const {

  return true;
}

void Room_LoadFlags::Swap(Room_LoadFlags* other) {
  if (other != this) {
    std::swap(treasure_, other->treasure_);
    std::swap(armour_, other->armour_);
    std::swap(weapon_, other->weapon_);
    std::swap(water_, other->water_);
    std::swap(food_, other->food_);
    std::swap(herb_, other->herb_);
    std::swap(key_, other->key_);
    std::swap(mule_, other->mule_);
    std::swap(horse_, other->horse_);
    std::swap(packhorse_, other->packhorse_);
    std::swap(trainedhorse_, other->trainedhorse_);
    std::swap(rohirrim_, other->rohirrim_);
    std::swap(warg_, other->warg_);
    std::swap(boat_, other->boat_);
    std::swap(attention_, other->attention_);
    std::swap(tower_, other->tower_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Room_LoadFlags::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Room_LoadFlags_descriptor_;
  metadata.reflection = Room_LoadFlags_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Room_Coordinate::kXFieldNumber;
const int Room_Coordinate::kYFieldNumber;
const int Room_Coordinate::kZFieldNumber;
const int Room_Coordinate::kScaleFieldNumber;
#endif  // !_MSC_VER

Room_Coordinate::Room_Coordinate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Room_Coordinate::InitAsDefaultInstance() {
}

Room_Coordinate::Room_Coordinate(const Room_Coordinate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Room_Coordinate::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  scale_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Room_Coordinate::~Room_Coordinate() {
  SharedDtor();
}

void Room_Coordinate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Room_Coordinate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Room_Coordinate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_Coordinate_descriptor_;
}

const Room_Coordinate& Room_Coordinate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Room_Coordinate* Room_Coordinate::default_instance_ = NULL;

Room_Coordinate* Room_Coordinate::New() const {
  return new Room_Coordinate;
}

void Room_Coordinate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    z_ = 0;
    scale_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Room_Coordinate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_scale;
        break;
      }

      // optional float scale = 4 [default = 1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Room_Coordinate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  // optional float scale = 4 [default = 1];
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->scale(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Room_Coordinate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  // optional float scale = 4 [default = 1];
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->scale(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Room_Coordinate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // required float z = 3;
    if (has_z()) {
      total_size += 1 + 4;
    }

    // optional float scale = 4 [default = 1];
    if (has_scale()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Room_Coordinate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Room_Coordinate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Room_Coordinate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Room_Coordinate::MergeFrom(const Room_Coordinate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Room_Coordinate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Room_Coordinate::CopyFrom(const Room_Coordinate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room_Coordinate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Room_Coordinate::Swap(Room_Coordinate* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(z_, other->z_);
    std::swap(scale_, other->scale_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Room_Coordinate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Room_Coordinate_descriptor_;
  metadata.reflection = Room_Coordinate_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

::std::string* Room::_default_area_name_ = NULL;
#ifndef _MSC_VER
const int Room::kIdFieldNumber;
const int Room::kNameFieldNumber;
const int Room::kDescFieldNumber;
const int Room::kPosFieldNumber;
const int Room::kAreaNameFieldNumber;
const int Room::kDynamicDescFieldNumber;
const int Room::kTerrainFieldNumber;
const int Room::kExitsFieldNumber;
const int Room::kNoteFieldNumber;
const int Room::kNoteColorFieldNumber;
const int Room::kInfoFieldNumber;
const int Room::kFlagPortableFieldNumber;
const int Room::kFlagLightFieldNumber;
const int Room::kFlagRideableFieldNumber;
const int Room::kFlagAlignFieldNumber;
const int Room::kMobFlagsFieldNumber;
const int Room::kLoadFlagsFieldNumber;
#endif  // !_MSC_VER

Room::Room()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Room::InitAsDefaultInstance() {
  pos_ = const_cast< ::mapdata::Room_Coordinate*>(&::mapdata::Room_Coordinate::default_instance());
  mob_flags_ = const_cast< ::mapdata::Room_MobFlags*>(&::mapdata::Room_MobFlags::default_instance());
  load_flags_ = const_cast< ::mapdata::Room_LoadFlags*>(&::mapdata::Room_LoadFlags::default_instance());
}

Room::Room(const Room& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Room::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pos_ = NULL;
  area_name_ = const_cast< ::std::string*>(_default_area_name_);
  dynamicdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  terrain_ = 0;
  note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  note_color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  flag_portable_ = 0;
  flag_light_ = 0;
  flag_rideable_ = 0;
  flag_align_ = 0;
  mob_flags_ = NULL;
  load_flags_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Room::~Room() {
  SharedDtor();
}

void Room::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (area_name_ != _default_area_name_) {
    delete area_name_;
  }
  if (dynamicdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete dynamicdesc_;
  }
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    delete note_;
  }
  if (note_color_ != &::google::protobuf::internal::kEmptyString) {
    delete note_color_;
  }
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (this != default_instance_) {
    delete pos_;
    delete mob_flags_;
    delete load_flags_;
  }
}

void Room::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Room::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Room_descriptor_;
}

const Room& Room::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_map_2eproto();
  return *default_instance_;
}

Room* Room::default_instance_ = NULL;

Room* Room::New() const {
  return new Room;
}

void Room::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_desc()) {
      if (desc_ != &::google::protobuf::internal::kEmptyString) {
        desc_->clear();
      }
    }
    if (has_pos()) {
      if (pos_ != NULL) pos_->::mapdata::Room_Coordinate::Clear();
    }
    if (has_area_name()) {
      if (area_name_ != _default_area_name_) {
        area_name_->assign(*_default_area_name_);
      }
    }
    if (has_dynamicdesc()) {
      if (dynamicdesc_ != &::google::protobuf::internal::kEmptyString) {
        dynamicdesc_->clear();
      }
    }
    terrain_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_note()) {
      if (note_ != &::google::protobuf::internal::kEmptyString) {
        note_->clear();
      }
    }
    if (has_note_color()) {
      if (note_color_ != &::google::protobuf::internal::kEmptyString) {
        note_color_->clear();
      }
    }
    if (has_info()) {
      if (info_ != &::google::protobuf::internal::kEmptyString) {
        info_->clear();
      }
    }
    flag_portable_ = 0;
    flag_light_ = 0;
    flag_rideable_ = 0;
    flag_align_ = 0;
    if (has_mob_flags()) {
      if (mob_flags_ != NULL) mob_flags_->::mapdata::Room_MobFlags::Clear();
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (has_load_flags()) {
      if (load_flags_ != NULL) load_flags_->::mapdata::Room_LoadFlags::Clear();
    }
  }
  exits_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Room::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_desc;
        break;
      }

      // required string desc = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_desc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->desc().data(), this->desc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_pos;
        break;
      }

      // required .mapdata.Room.Coordinate pos = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_area_name;
        break;
      }

      // optional string area_name = 6 [default = "default"];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_area_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_area_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->area_name().data(), this->area_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_dynamicDesc;
        break;
      }

      // optional string dynamicDesc = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dynamicDesc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dynamicdesc()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->dynamicdesc().data(), this->dynamicdesc().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_terrain;
        break;
      }

      // optional .mapdata.Room.RoomTerrainType terrain = 8 [default = RTT_UNDEFINED];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_terrain:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapdata::Room_RoomTerrainType_IsValid(value)) {
            set_terrain(static_cast< ::mapdata::Room_RoomTerrainType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_exits;
        break;
      }

      // repeated .mapdata.Exit exits = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exits()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_exits;
        if (input->ExpectTag(122)) goto parse_note;
        break;
      }

      // optional string note = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_note:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_note()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->note().data(), this->note().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_note_color;
        break;
      }

      // optional string note_color = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_note_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_note_color()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->note_color().data(), this->note_color().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_info;
        break;
      }

      // optional string info = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_info()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->info().data(), this->info().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_flag_portable;
        break;
      }

      // optional .mapdata.Room.RoomPortableType flag_portable = 18 [default = RPT_UNDEFINED];
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag_portable:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapdata::Room_RoomPortableType_IsValid(value)) {
            set_flag_portable(static_cast< ::mapdata::Room_RoomPortableType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(18, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_flag_light;
        break;
      }

      // optional .mapdata.Room.RoomLightType flag_light = 19 [default = RLT_UNDEFINED];
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag_light:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapdata::Room_RoomLightType_IsValid(value)) {
            set_flag_light(static_cast< ::mapdata::Room_RoomLightType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(19, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_flag_rideable;
        break;
      }

      // optional .mapdata.Room.RoomRidableType flag_rideable = 20 [default = RRT_UNDEFINED];
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag_rideable:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapdata::Room_RoomRidableType_IsValid(value)) {
            set_flag_rideable(static_cast< ::mapdata::Room_RoomRidableType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(20, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_flag_align;
        break;
      }

      // optional .mapdata.Room.RoomAlignType flag_align = 21 [default = RAT_UNDEFINED];
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag_align:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mapdata::Room_RoomAlignType_IsValid(value)) {
            set_flag_align(static_cast< ::mapdata::Room_RoomAlignType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(21, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_mob_flags;
        break;
      }

      // optional .mapdata.Room.MobFlags mob_flags = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mob_flags:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mob_flags()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(186)) goto parse_load_flags;
        break;
      }

      // optional .mapdata.Room.LoadFlags load_flags = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_load_flags:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_load_flags()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Room::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // required string desc = 3;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->desc(), output);
  }

  // required .mapdata.Room.Coordinate pos = 4;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->pos(), output);
  }

  // optional string area_name = 6 [default = "default"];
  if (has_area_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->area_name().data(), this->area_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->area_name(), output);
  }

  // optional string dynamicDesc = 7;
  if (has_dynamicdesc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dynamicdesc().data(), this->dynamicdesc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->dynamicdesc(), output);
  }

  // optional .mapdata.Room.RoomTerrainType terrain = 8 [default = RTT_UNDEFINED];
  if (has_terrain()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->terrain(), output);
  }

  // repeated .mapdata.Exit exits = 9;
  for (int i = 0; i < this->exits_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->exits(i), output);
  }

  // optional string note = 15;
  if (has_note()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->note().data(), this->note().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      15, this->note(), output);
  }

  // optional string note_color = 16;
  if (has_note_color()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->note_color().data(), this->note_color().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->note_color(), output);
  }

  // optional string info = 17;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      17, this->info(), output);
  }

  // optional .mapdata.Room.RoomPortableType flag_portable = 18 [default = RPT_UNDEFINED];
  if (has_flag_portable()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      18, this->flag_portable(), output);
  }

  // optional .mapdata.Room.RoomLightType flag_light = 19 [default = RLT_UNDEFINED];
  if (has_flag_light()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      19, this->flag_light(), output);
  }

  // optional .mapdata.Room.RoomRidableType flag_rideable = 20 [default = RRT_UNDEFINED];
  if (has_flag_rideable()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      20, this->flag_rideable(), output);
  }

  // optional .mapdata.Room.RoomAlignType flag_align = 21 [default = RAT_UNDEFINED];
  if (has_flag_align()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      21, this->flag_align(), output);
  }

  // optional .mapdata.Room.MobFlags mob_flags = 22;
  if (has_mob_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, this->mob_flags(), output);
  }

  // optional .mapdata.Room.LoadFlags load_flags = 23;
  if (has_load_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, this->load_flags(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Room::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // required string desc = 3;
  if (has_desc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->desc().data(), this->desc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->desc(), target);
  }

  // required .mapdata.Room.Coordinate pos = 4;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->pos(), target);
  }

  // optional string area_name = 6 [default = "default"];
  if (has_area_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->area_name().data(), this->area_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->area_name(), target);
  }

  // optional string dynamicDesc = 7;
  if (has_dynamicdesc()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->dynamicdesc().data(), this->dynamicdesc().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->dynamicdesc(), target);
  }

  // optional .mapdata.Room.RoomTerrainType terrain = 8 [default = RTT_UNDEFINED];
  if (has_terrain()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->terrain(), target);
  }

  // repeated .mapdata.Exit exits = 9;
  for (int i = 0; i < this->exits_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->exits(i), target);
  }

  // optional string note = 15;
  if (has_note()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->note().data(), this->note().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->note(), target);
  }

  // optional string note_color = 16;
  if (has_note_color()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->note_color().data(), this->note_color().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->note_color(), target);
  }

  // optional string info = 17;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        17, this->info(), target);
  }

  // optional .mapdata.Room.RoomPortableType flag_portable = 18 [default = RPT_UNDEFINED];
  if (has_flag_portable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      18, this->flag_portable(), target);
  }

  // optional .mapdata.Room.RoomLightType flag_light = 19 [default = RLT_UNDEFINED];
  if (has_flag_light()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      19, this->flag_light(), target);
  }

  // optional .mapdata.Room.RoomRidableType flag_rideable = 20 [default = RRT_UNDEFINED];
  if (has_flag_rideable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      20, this->flag_rideable(), target);
  }

  // optional .mapdata.Room.RoomAlignType flag_align = 21 [default = RAT_UNDEFINED];
  if (has_flag_align()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      21, this->flag_align(), target);
  }

  // optional .mapdata.Room.MobFlags mob_flags = 22;
  if (has_mob_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        22, this->mob_flags(), target);
  }

  // optional .mapdata.Room.LoadFlags load_flags = 23;
  if (has_load_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        23, this->load_flags(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Room::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string desc = 3;
    if (has_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->desc());
    }

    // required .mapdata.Room.Coordinate pos = 4;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

    // optional string area_name = 6 [default = "default"];
    if (has_area_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->area_name());
    }

    // optional string dynamicDesc = 7;
    if (has_dynamicdesc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dynamicdesc());
    }

    // optional .mapdata.Room.RoomTerrainType terrain = 8 [default = RTT_UNDEFINED];
    if (has_terrain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->terrain());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string note = 15;
    if (has_note()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->note());
    }

    // optional string note_color = 16;
    if (has_note_color()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->note_color());
    }

    // optional string info = 17;
    if (has_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->info());
    }

    // optional .mapdata.Room.RoomPortableType flag_portable = 18 [default = RPT_UNDEFINED];
    if (has_flag_portable()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->flag_portable());
    }

    // optional .mapdata.Room.RoomLightType flag_light = 19 [default = RLT_UNDEFINED];
    if (has_flag_light()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->flag_light());
    }

    // optional .mapdata.Room.RoomRidableType flag_rideable = 20 [default = RRT_UNDEFINED];
    if (has_flag_rideable()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->flag_rideable());
    }

    // optional .mapdata.Room.RoomAlignType flag_align = 21 [default = RAT_UNDEFINED];
    if (has_flag_align()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->flag_align());
    }

    // optional .mapdata.Room.MobFlags mob_flags = 22;
    if (has_mob_flags()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mob_flags());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .mapdata.Room.LoadFlags load_flags = 23;
    if (has_load_flags()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->load_flags());
    }

  }
  // repeated .mapdata.Exit exits = 9;
  total_size += 1 * this->exits_size();
  for (int i = 0; i < this->exits_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exits(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Room::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Room* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Room*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Room::MergeFrom(const Room& from) {
  GOOGLE_CHECK_NE(&from, this);
  exits_.MergeFrom(from.exits_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_desc()) {
      set_desc(from.desc());
    }
    if (from.has_pos()) {
      mutable_pos()->::mapdata::Room_Coordinate::MergeFrom(from.pos());
    }
    if (from.has_area_name()) {
      set_area_name(from.area_name());
    }
    if (from.has_dynamicdesc()) {
      set_dynamicdesc(from.dynamicdesc());
    }
    if (from.has_terrain()) {
      set_terrain(from.terrain());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_note()) {
      set_note(from.note());
    }
    if (from.has_note_color()) {
      set_note_color(from.note_color());
    }
    if (from.has_info()) {
      set_info(from.info());
    }
    if (from.has_flag_portable()) {
      set_flag_portable(from.flag_portable());
    }
    if (from.has_flag_light()) {
      set_flag_light(from.flag_light());
    }
    if (from.has_flag_rideable()) {
      set_flag_rideable(from.flag_rideable());
    }
    if (from.has_flag_align()) {
      set_flag_align(from.flag_align());
    }
    if (from.has_mob_flags()) {
      mutable_mob_flags()->::mapdata::Room_MobFlags::MergeFrom(from.mob_flags());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_load_flags()) {
      mutable_load_flags()->::mapdata::Room_LoadFlags::MergeFrom(from.load_flags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Room::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Room::CopyFrom(const Room& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Room::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_pos()) {
    if (!this->pos().IsInitialized()) return false;
  }
  for (int i = 0; i < exits_size(); i++) {
    if (!this->exits(i).IsInitialized()) return false;
  }
  return true;
}

void Room::Swap(Room* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(desc_, other->desc_);
    std::swap(pos_, other->pos_);
    std::swap(area_name_, other->area_name_);
    std::swap(dynamicdesc_, other->dynamicdesc_);
    std::swap(terrain_, other->terrain_);
    exits_.Swap(&other->exits_);
    std::swap(note_, other->note_);
    std::swap(note_color_, other->note_color_);
    std::swap(info_, other->info_);
    std::swap(flag_portable_, other->flag_portable_);
    std::swap(flag_light_, other->flag_light_);
    std::swap(flag_rideable_, other->flag_rideable_);
    std::swap(flag_align_, other->flag_align_);
    std::swap(mob_flags_, other->mob_flags_);
    std::swap(load_flags_, other->load_flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Room::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Room_descriptor_;
  metadata.reflection = Room_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace mapdata

// @@protoc_insertion_point(global_scope)
